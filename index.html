<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>WebFEA - 2D Frame Analysis</title>
    
    <!-- Tailwind CSS -->
    <script src="https://cdn.tailwindcss.com"></script>
    
    <!-- React & ReactDOM -->
    <script crossorigin src="https://unpkg.com/react@18/umd/react.development.js"></script>
    <script crossorigin src="https://unpkg.com/react-dom@18/umd/react-dom.development.js"></script>
    
    <!-- Babel -->
    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>

    <!-- Lucide Icons -->
    <script src="https://unpkg.com/lucide@latest"></script>

    <style>
        body { background-color: #0f172a; color: #e2e8f0; overflow: hidden; }
        canvas { touch-action: none; }
        /* Custom Scrollbar */
        ::-webkit-scrollbar { width: 8px; height: 8px; }
        ::-webkit-scrollbar-track { background: #1e293b; }
        ::-webkit-scrollbar-thumb { background: #475569; border-radius: 4px; }
        ::-webkit-scrollbar-thumb:hover { background: #64748b; }
        .input-dark {
            @apply bg-slate-800 border border-slate-600 rounded px-2 py-1 text-xs w-full focus:outline-none focus:border-blue-500;
        }
        .tool-btn {
            @apply flex items-center gap-2 px-3 py-2 rounded text-xs font-bold transition-colors w-full border border-transparent;
        }
        .tool-btn.active {
            @apply bg-blue-600 border-blue-400 text-white shadow-md;
        }
        .tool-btn.inactive {
            @apply bg-slate-800 text-slate-400 hover:bg-slate-700 hover:text-slate-200;
        }
    </style>
</head>
<body>

    <div id="root"></div>

    <script type="text/babel">
        const { useState, useEffect, useRef, useMemo, useCallback } = React;

        // ==========================================
        // TIER 1: DATA/LOGIC LAYER (THE ENGINE)
        // ==========================================

        const Matrix = {
            zeros: (r, c) => Array(r).fill(0).map(() => Array(c).fill(0)),
            
            multiply: (A, B) => {
                const rA = A.length, cA = A[0].length, rB = B.length, cB = B[0].length;
                if (cA !== rB) throw new Error("Matrix dimension mismatch");
                let C = Matrix.zeros(rA, cB);
                for (let i = 0; i < rA; i++) {
                    for (let j = 0; j < cB; j++) {
                        let sum = 0;
                        for (let k = 0; k < cA; k++) sum += A[i][k] * B[k][j];
                        C[i][j] = sum;
                    }
                }
                return C;
            },

            transpose: (A) => A[0].map((_, c) => A.map(r => r[c])),

            // Solves Ax = b using Gaussian Elimination with partial pivoting
            solve: (A, b) => {
                const n = A.length;
                let M = A.map((row, i) => [...row, b[i]]); 

                for (let i = 0; i < n; i++) {
                    let maxRow = i;
                    for (let k = i + 1; k < n; k++) {
                        if (Math.abs(M[k][i]) > Math.abs(M[maxRow][i])) maxRow = k;
                    }
                    
                    [M[i], M[maxRow]] = [M[maxRow], M[i]];

                    if (Math.abs(M[i][i]) < 1e-10) throw new Error("Singular Matrix: Structure is unstable.");

                    for (let k = i + 1; k < n; k++) {
                        const factor = M[k][i] / M[i][i];
                        for (let j = i; j <= n; j++) {
                            M[k][j] -= factor * M[i][j];
                        }
                    }
                }

                const x = Array(n).fill(0);
                for (let i = n - 1; i >= 0; i--) {
                    let sum = 0;
                    for (let j = i + 1; j < n; j++) sum += M[i][j] * x[j];
                    x[i] = (M[i][n] - sum) / M[i][i];
                }
                return x;
            }
        };

        class FrameSolver {
            constructor(nodes, elements, supports, loads) {
                this.nodes = nodes;
                this.elements = elements;
                this.supports = supports;
                this.loads = loads;
                this.dofPerNode = 3;
                this.totalDof = nodes.length * this.dofPerNode;
            }

            calculate() {
                try {
                    // 1. Init
                    let K = Matrix.zeros(this.totalDof, this.totalDof);
                    let F = Array(this.totalDof).fill(0); 
                    let D_known = Array(this.totalDof).fill(0); 
                    let fixedEndForces = {}; 

                    // 2. Assemble Stiffness
                    this.elements.forEach(el => {
                        const n1 = this.nodes[el.n1];
                        const n2 = this.nodes[el.n2];
                        const dx = n2.x - n1.x, dy = n2.y - n1.y;
                        const L = Math.sqrt(dx*dx + dy*dy);
                        const c = dx / L, s = dy / L;
                        
                        const { E, A, I } = el;
                        const isTruss = el.type === 'truss';

                        const k1 = (E*A)/L;
                        const k2 = isTruss ? 0 : (12*E*I)/(L*L*L);
                        const k3 = isTruss ? 0 : (6*E*I)/(L*L);
                        const k4 = isTruss ? 0 : (4*E*I)/L;
                        const k5 = isTruss ? 0 : (2*E*I)/L;

                        const k_local = [
                            [k1, 0, 0, -k1, 0, 0],
                            [0, k2, k3, 0, -k2, k3],
                            [0, k3, k4, 0, -k3, k5],
                            [-k1, 0, 0, k1, 0, 0],
                            [0, -k2, -k3, 0, k2, -k3],
                            [0, k3, k5, 0, -k3, k4]
                        ];

                        const T = [
                            [c, s, 0, 0, 0, 0], [-s, c, 0, 0, 0, 0], [0, 0, 1, 0, 0, 0],
                            [0, 0, 0, c, s, 0], [0, 0, 0, -s, c, 0], [0, 0, 0, 0, 0, 1]
                        ];

                        const k_global = Matrix.multiply(Matrix.multiply(Matrix.transpose(T), k_local), T);
                        const idx = [3*el.n1, 3*el.n1+1, 3*el.n1+2, 3*el.n2, 3*el.n2+1, 3*el.n2+2];

                        for(let i=0; i<6; i++){
                            for(let j=0; j<6; j++){
                                K[idx[i]][idx[j]] += k_global[i][j];
                            }
                        }
                    });

                    // Singularity Patch for Truss Nodes
                    for(let i=0; i<this.totalDof; i++) {
                        if (i % 3 === 2 && Math.abs(K[i][i]) < 1e-9) K[i][i] = 1.0;
                    }

                    // 3. Process Loads
                    let restrainedDofSet = new Set();
                    this.supports.forEach(supp => {
                        const base = 3 * supp.nodeId;
                        if(supp.rx) restrainedDofSet.add(base);
                        if(supp.ry) restrainedDofSet.add(base+1);
                        if(supp.rm) restrainedDofSet.add(base+2);
                    });

                    // Helper: Add Global Force to Node
                    const addGlobalF = (nodeId, fx, fy, m) => {
                        F[3*nodeId] += fx; F[3*nodeId+1] += fy; F[3*nodeId+2] += m;
                    };

                    this.loads.forEach(load => {
                        // A. NODAL LOADS (Directly added)
                        if (load.type === 'point' && load.nodeId !== undefined) {
                            addGlobalF(load.nodeId, parseFloat(load.fx || 0), parseFloat(load.fy || 0), parseFloat(load.m || 0));
                        }
                        
                        // B. SETTLEMENTS (Displacement Loads)
                        else if (load.type === 'settlement') {
                            const idx = 3 * load.nodeId;
                            if (load.dx) { D_known[idx] += parseFloat(load.dx); restrainedDofSet.add(idx); }
                            if (load.dy) { D_known[idx+1] += parseFloat(load.dy); restrainedDofSet.add(idx+1); }
                            if (load.dm) { D_known[idx+2] += parseFloat(load.dm); restrainedDofSet.add(idx+2); }
                        }

                        // C. ELEMENT LOADS (Point on Span OR Distributed)
                        else if ((load.type === 'dist' || load.type === 'point_span') && load.elementId !== undefined) {
                            const el = this.elements.find(e => e.id === load.elementId);
                            if (el) {
                                const n1 = this.nodes[el.n1], n2 = this.nodes[el.n2];
                                const dx = n2.x - n1.x, dy = n2.y - n1.y;
                                const L = Math.sqrt(dx*dx + dy*dy);
                                const cos = dx/L, sin = dy/L;

                                // 1. Determine Local Forces based on Input Angle
                                // User Input: Global Angle (0=Right, 90=Up). Local Beam Angle = atan2(dy, dx)
                                // Relative Angle = LoadAngle - BeamAngle
                                let fx_local_p1 = 0, fy_local_p1 = 0, m_local_1 = 0;
                                let fx_local_p2 = 0, fy_local_p2 = 0, m_local_2 = 0;

                                // Helper: Accumulate Fixed End Actions
                                const addFEA = (fx1, fy1, m1, fx2, fy2, m2) => {
                                    fx_local_p1 += fx1; fy_local_p1 += fy1; m_local_1 += m1;
                                    fx_local_p2 += fx2; fy_local_p2 += fy2; m_local_2 += m2;
                                };

                                // NEW HELPER: Get Global Angle from Load Config
                                const getRealAngle = (l) => {
                                    const raw = parseFloat(l.angle !== undefined ? l.angle : -90);
                                    const rad = raw * Math.PI / 180;
                                    if (l.angleRef === 'local') {
                                        // Standard Local: 0 = Axial, -90 = Transverse (Down/Right)
                                        const beamAng = Math.atan2(dy, dx);
                                        return beamAng + rad; 
                                    }
                                    return rad; // Global
                                };

                                if (load.type === 'point_span') {
                                    const mag = parseFloat(load.mag || 0);
                                    
                                    const angGlob = getRealAngle(load); 
                                    // MODIFY: Check for undefined explicitly so '0' is not treated as false
                                    const distVal = load.dist !== undefined ? load.dist : L/2;
                                    const a = Math.max(0, Math.min(L, parseFloat(distVal)));
                                    
                                    // ADD THIS LINE:
                                    const b = L - a;

                                    // Project global force into local beam coordinates
                                    // Global Force Vector: [mag*cos(ang), mag*sin(ang)]
                                    // Local Transform: Fx_loc = Fx_glob*c + Fy_glob*s ... wait, standard rotation matrix
                                    const Fx_glob = mag * Math.cos(angGlob);
                                    const Fy_glob = mag * Math.sin(angGlob);
                                    
                                    // Local components (Parallel and Perpendicular to beam)
                                    const Px = Fx_glob * cos + Fy_glob * sin; 
                                    const Py = -Fx_glob * sin + Fy_glob * cos; // Positive Py is "Local Up" (away from beam axis usually, but consistent with CCW moments)

                                    // Fixed End Actions for Py (Transverse)
                                    // M1 = P*a*b^2 / L^2, M2 = -P*a^2*b / L^2 (Standard CCW+ convention)
                                    // Reaction V1 = Pb/L + (M1+M2)/L ... standard formulas:
                                    const M1 = (Py * a * b * b) / (L * L);
                                    const M2 = -(Py * a * a * b) / (L * L);
                                    const V1 = (Py * b * b * (3 * a + b)) / (L * L * L); // Standard fixed-fixed reaction
                                    const V2 = (Py * a * a * (a + 3 * b)) / (L * L * L);

                                    // Axial Distribution (Linear)
                                    const Ax1 = -Px * (b / L); 
                                    const Ax2 = -Px * (a / L);

                                    addFEA(Ax1, V1, M1, Ax2, V2, M2);
                                } 
                                else if (load.type === 'dist') {
                                    // Trapezoidal Partial Load
                                    // Inputs
                                    const w1 = parseFloat(load.wStart || 0); // Start Mag
                                    const w2 = parseFloat(load.wEnd !== undefined ? load.wEnd : load.wStart || 0); // End Mag
                                    const d1 = Math.max(0, Math.min(L, parseFloat(load.dStart || 0)));
                                    const d2 = Math.max(0, Math.min(L, parseFloat(load.dEnd !== undefined ? load.dEnd : L)));
                                    
                                    if(d2 > d1) {
                                        // REPLACED
                                        const angGlob = getRealAngle(load);
                                        
                                        const nx = Math.cos(angGlob);
                                        const ny = Math.sin(angGlob);
                                        
                                        // Decompose to Local W vectors (at start and end of load segment)
                                        // w_local_x = w * (nx*c + ny*s)
                                        // w_local_y = w * (-nx*s + ny*c)
                                        
                                        const wx1 = w1 * (nx * cos + ny * sin);
                                        const wy1 = w1 * (-nx * sin + ny * cos);
                                        const wx2 = w2 * (nx * cos + ny * sin);
                                        const wy2 = w2 * (-nx * sin + ny * cos);

                                        // INTEGRATION for FEA (Exact method for partial linear load)
                                        // We integrate influence lines: m1(x) = x(L-x)^2/L^2, m2(x) = -x^2(L-x)/L^2
                                        // Load function W(x) from d1 to d2: linear interpolation between w_start and w_end
                                        
                                        const distLen = d2 - d1;
                                        
                                        // Numerical Integration (Simpson's rule is exact for cubic * linear = quartic? No, Gaussian 3-pt is safer)
                                        // Actually, let's just use 5-point simpson for precision, it's fast enough.
                                        const steps = 10;
                                        const h = distLen / steps;
                                        
                                        for(let i=0; i<=steps; i++) {
                                            const x = d1 + i*h; // global x on beam from n1
                                            const s = (x - d1) / distLen; // 0 to 1 along load
                                            
                                            const wy = wy1 * (1-s) + wy2 * s; // Local Transverse Load at x
                                            const wx = wx1 * (1-s) + wx2 * s; // Local Axial Load at x
                                            
                                            // Weight for Simpson's
                                            const weight = (i===0 || i===steps) ? 1 : (i%2===1 ? 4 : 2);
                                            const eff_w = (weight * h) / 3;

                                            // Bending FEA (Hermite Shape Functions)
                                            // N1 = 1 - 3x²/L² + 2x³/L³ ... wait, that's displacement.
                                            // We need Fixed End Reactions for load P = (wy * dx)
                                            const a = x, b = L - x;
                                            
                                            // Differential FEA for point load dP = wy * dx
                                            const dM1 = (wy * a * b * b) / (L * L);
                                            const dM2 = -(wy * a * a * b) / (L * L);
                                            const dV1 = (wy * b * b * (3 * a + b)) / (L * L * L); // Reaction 1
                                            const dV2 = (wy * a * a * (a + 3 * b)) / (L * L * L); // Reaction 2

                                            // Axial FEA
                                            const dAx1 = -wx * (b/L);
                                            const dAx2 = -wx * (a/L);

                                            addFEA(dAx1 * eff_w, dV1 * eff_w, dM1 * eff_w, dAx2 * eff_w, dV2 * eff_w, dM2 * eff_w);
                                        }
                                    }
                                }

                                // 2. Convert Local Fixed Actions to Global & Subtract from F (Action -> Reaction -> Apply Opposite to Nodes)
                                // We computed ACTIONS (Forces exerted by beam on nodes due to load). 
                                // We subtract them from external F vector (or add -Action).
                                
                                // Global transformation of Node 1 forces
                                const Fx1_g = fx_local_p1 * cos - fy_local_p1 * sin;
                                const Fy1_g = fx_local_p1 * sin + fy_local_p1 * cos;
                                const M1_g = m_local_1;

                                const Fx2_g = fx_local_p2 * cos - fy_local_p2 * sin;
                                const Fy2_g = fx_local_p2 * sin + fy_local_p2 * cos;
                                const M2_g = m_local_2;

                                // [MODIFY] Change signs from negative (-) to positive (+) to apply ACTION correctly
                                addGlobalF(el.n1, Fx1_g, Fy1_g, M1_g);
                                addGlobalF(el.n2, Fx2_g, Fy2_g, M2_g);

                                // Store for internal calculation
                                if (!fixedEndForces[el.id]) fixedEndForces[el.id] = Array(6).fill(0);
                                fixedEndForces[el.id][0] += fx_local_p1;
                                fixedEndForces[el.id][1] += fy_local_p1;
                                fixedEndForces[el.id][2] += m_local_1;
                                fixedEndForces[el.id][3] += fx_local_p2;
                                fixedEndForces[el.id][4] += fy_local_p2;
                                fixedEndForces[el.id][5] += m_local_2;
                            }
                        }
                    });

                    // 4. Partitioning & Solve
                    let freeDofMap = [], restrainedDofList = [];
                    for(let i=0; i<this.totalDof; i++) {
                        if(!restrainedDofSet.has(i)) freeDofMap.push(i);
                        else restrainedDofList.push(i);
                    }

                    if(freeDofMap.length === 0) throw new Error("Structure is fully constrained.");

                    let K_ff = Matrix.zeros(freeDofMap.length, freeDofMap.length);
                    let F_f_eff = Array(freeDofMap.length).fill(0);

                    for(let i=0; i<freeDofMap.length; i++){
                        const row = freeDofMap[i];
                        F_f_eff[i] = F[row];
                        for(let j=0; j<freeDofMap.length; j++) K_ff[i][j] = K[row][freeDofMap[j]];
                        for(let k=0; k<restrainedDofList.length; k++){
                            const col = restrainedDofList[k];
                            if (Math.abs(D_known[col]) > 1e-9) F_f_eff[i] -= K[row][col] * D_known[col];
                        }
                    }

                    const d_free = Matrix.solve(K_ff, F_f_eff);
                    const Displacements = [...D_known];
                    freeDofMap.forEach((globalIdx, i) => Displacements[globalIdx] = d_free[i]);

                    // 5. Member Forces & Reactions
                    let R_accum = Array(this.totalDof).fill(0); // Accumulator for reactions

                    const MemberForces = this.elements.map(el => {
                        const n1 = this.nodes[el.n1], n2 = this.nodes[el.n2];
                        const dx = n2.x - n1.x, dy = n2.y - n1.y;
                        const L = Math.sqrt(dx*dx + dy*dy);
                        const c = dx / L, s = dy / L;

                        const T = [
                            [c, s, 0, 0, 0, 0], [-s, c, 0, 0, 0, 0], [0, 0, 1, 0, 0, 0],
                            [0, 0, 0, c, s, 0], [0, 0, 0, -s, c, 0], [0, 0, 0, 0, 0, 1]
                        ];
                        
                        const { E, A, I } = el;
                        const isTruss = el.type === 'truss';
                        const k1 = (E*A)/L;
                        const k2 = isTruss ? 0 : (12*E*I)/(L*L*L);
                        const k3 = isTruss ? 0 : (6*E*I)/(L*L);
                        const k4 = isTruss ? 0 : (4*E*I)/L;
                        const k5 = isTruss ? 0 : (2*E*I)/L;

                        const k_local = [
                            [k1, 0, 0, -k1, 0, 0], [0, k2, k3, 0, -k2, k3], [0, k3, k4, 0, -k3, k5],
                            [-k1, 0, 0, k1, 0, 0], [0, -k2, -k3, 0, k2, -k3], [0, k3, k5, 0, -k3, k4]
                        ];

                        const d_global_el = [
                            Displacements[3*el.n1], Displacements[3*el.n1+1], Displacements[3*el.n1+2],
                            Displacements[3*el.n2], Displacements[3*el.n2+1], Displacements[3*el.n2+2]
                        ];

                        let u_local = Array(6).fill(0);
                        for(let i=0; i<6; i++) for(let j=0; j<6; j++) u_local[i] += T[i][j] * d_global_el[j];

                        let f_local = Array(6).fill(0);
                        // CORRECT MATRIX MULTIPLICATION: Row i, Col j matches Vector j
                        for(let i=0; i<6; i++) for(let j=0; j<6; j++) f_local[i] += k_local[i][j] * u_local[j];

                        // [MODIFY] Change += to -= to convert Action (on Node) to Reaction (on Member)
                        // This corrects the shear, moment, and reaction calculations
                        if (fixedEndForces[el.id]) {
                            for(let k=0; k<6; k++) f_local[k] -= fixedEndForces[el.id][k];
                        }

                        // REACTION CALC: Transform local forces to global and accumulate at nodes
                        // f_global = T_transpose * f_local
                        const T_t = Matrix.transpose(T);
                        let f_global_el = Array(6).fill(0);
                        for(let i=0; i<6; i++) {
                            for(let j=0; j<6; j++) f_global_el[i] += T_t[i][j] * f_local[j];
                        }
                        
                        // Add to Node 1 Global Forces
                        R_accum[3*el.n1]   += f_global_el[0];
                        R_accum[3*el.n1+1] += f_global_el[1];
                        R_accum[3*el.n1+2] += f_global_el[2];
                        // Add to Node 2 Global Forces
                        R_accum[3*el.n2]   += f_global_el[3];
                        R_accum[3*el.n2+1] += f_global_el[4];
                        R_accum[3*el.n2+2] += f_global_el[5];

                        return {
                            id: el.id,
                            globalForces: f_global_el, // ADD: Store global forces [Fx1, Fy1, M1, Fx2, Fy2, M2]
                            axial: f_local[3],       // Fx at node 2
                            shearStart: f_local[1],  // Fy at node 1
                            shearEnd: f_local[4],    // Fy at node 2
                            moment1: f_local[2],     // Mz at node 1
                            moment2: f_local[5],     // Mz at node 2
                            dispLocal: u_local
                        };
                    });

                    // Finalize Reactions: Subtract Applied Nodal Loads (Reaction = Internal - External)
                    // We re-loop loads to subtract nodal loads from the accumulator
                    this.loads.forEach(l => {
                        if (l.type === 'point' && l.nodeId !== undefined) {
                            R_accum[3*l.nodeId]   -= parseFloat(l.fx || 0);
                            R_accum[3*l.nodeId+1] -= parseFloat(l.fy || 0);
                            R_accum[3*l.nodeId+2] -= parseFloat(l.m || 0);
                        }
                    });

                    return { displacements: Displacements, memberForces: MemberForces, reactions: R_accum };
                } catch (err) { throw err; }
            }
        }


        // ==========================================
        // TIER 3: PRESENTATION (CANVAS COMPONENTS)
        // ==========================================

        const CanvasView = ({ 
            nodes, elements, supports, loads, results, 
            viewSettings, tool, selectedNode, selectedElement, selectedLoad, 
            onCanvasInteract, textSize, isDarkMode, t // <--- ADD t PROP
        }) => {
            const canvasRef = useRef(null);
            const [pan, setPan] = useState({ x: 100, y: 500 });
            const [zoom, setZoom] = useState(40);
            const [isDragging, setIsDragging] = useState(false);
            const [dragStart, setDragStart] = useState({ x: 0, y: 0 });
            const [mousePos, setMousePos] = useState({ x: 0, y: 0 });
            
            // ADDED: Hover State
            const [hoverData, setHoverData] = useState(null);

            // ROBUST INTEGRATOR: Calculates internal forces at any x by summing load effects
            const getBeamValues = (el, x, L) => {
                if (!results) return null;
                const res = results.memberForces.find(f => f.id === el.id);
                
                // 1. Start with Nodal Forces (Local)
                // Note: res.moment1 is the Nodal Action (CCW). Internal Moment M(x) convention usually starts opposite.
                // We use standard beam sign convention: Sagging Positive.
                let Mx = -res.moment1 + res.shearStart * x; // Moment from reactions
                let Vx = res.shearStart;                    // Shear from reactions
                let Ax = res.axial;                         // Axial from reactions
                
                // 2. Subtract effect of loads applied between 0 and x
                const elLoads = loads.filter(l => (l.type === 'dist' || l.type === 'point_span') && l.elementId === el.id);
                
                elLoads.forEach(l => {
                    // Resolve Load Vector relative to Beam
                    const rawAng = (parseFloat(l.angle !== undefined ? l.angle : -90) * Math.PI) / 180;
                    
                    // Beam Angle
                    const n1 = nodes[el.n1], n2 = nodes[el.n2];
                    const dx = n2.x - n1.x, dy = n2.y - n1.y;
                    const beamAng = Math.atan2(dy, dx);
                    
                    // Effective Global Angle
                    let effectiveAng = rawAng;
                    if (l.angleRef === 'local') {
                        // Standard Local Logic (No offset)
                        effectiveAng = beamAng + rawAng;
                    }
                    
                    // Relative Angle (Load vs Beam) for component decomposition
                    const relAng = effectiveAng - beamAng;
                    if (l.type === 'point_span') {
                            // Clamp distance to Element Length L
                            // MODIFY: Explicit undefined check allowing 0
                            let dist = parseFloat(l.dist !== undefined ? l.dist : L/2);
                            dist = Math.max(0, Math.min(L, dist));
                            
                            // 't' is not needed here, removed to prevent reference errors
                        if (x > dist) {
                            const mag = parseFloat(l.mag || 0);
                            const Px = mag * Math.cos(relAng); // Axial component
                            const Py = mag * Math.sin(relAng); // Transverse component (Up+)
                            
                            // Load P opposes the Internal Shear/Axial definition usually? 
                            // Standard cut: V is down face. Sum Fy=0 -> V - V_start + P = 0 -> V = V_start - P
                            Vx += Py;
                            Ax += Px;
                            Mx += Py * (x - dist);
                        }
                    } 
                    else if (l.type === 'dist') {
                        const d1 = parseFloat(l.dStart || 0);
                        const d2 = parseFloat(l.dEnd !== undefined ? l.dEnd : L);
                        
                        // Intersection of load span [d1, d2] and current check [0, x]
                        const start = Math.max(d1, 0);
                        const end = Math.min(d2, x);
                        
                        if (end > start) {
                            const len = end - start;
                            const wStart = parseFloat(l.wStart || 0);
                            const wEnd = parseFloat(l.wEnd !== undefined ? l.wEnd : wStart);
                            
                            // Interpolated w at start/end of the active segment
                            const fullLen = d2 - d1;
                            const w_at_start = wStart + (wEnd - wStart) * ((start - d1) / fullLen);
                            const w_at_end = wStart + (wEnd - wStart) * ((end - d1) / fullLen);
                            
                            // Components (Trapezoidal load area)
                            const area = (w_at_start + w_at_end) * 0.5 * len;
                            const centroidLocal = (len * (w_at_start + 2*w_at_end)) / (3 * (w_at_start + w_at_end)); // Centroid from 'start'
                            const centroidDist = (x - start) - centroidLocal; // Lever arm to x
                            
                            // Vector components
                            const Wx = area * Math.cos(relAng);
                            const Wy = area * Math.sin(relAng);
                            
                            Vx += Wy;
                            Ax += Wx;
                            Mx += Wy * centroidDist;
                        }
                    }
                });

                // Deflection Approximation (Superposition of Nodal Hermite + Simple beam Approx)
                // Note: Exact deflection for partial trapezoidal loads is complex. 
                // We keep the cubic nodal shape which is 95% of the visual.
                const t = x / L;
                const v1 = res.dispLocal[1], th1 = res.dispLocal[2];
                const v2 = res.dispLocal[4], th2 = res.dispLocal[5];
                const h1 = 1 - 3*t*t + 2*t*t*t;
                const h2 = x * (1 - 2*t + t*t);
                const h3 = 3*t*t - 2*t*t*t;
                const h4 = x * (t*t - t);
                let disp = v1*h1 + th1*h2 + v2*h3 + th2*h4;

                return { mx: Mx, vx: Vx, ax: Ax, disp };
            };

            // ADDED: Calculate dynamic grid step
            const gridStep = useMemo(() => {
                // High Zoom (>= 40px/m): Binary subdivision (0.5, 0.25, 0.125...) for precision
                if (zoom >= 40) {
                    return 0.5 / Math.pow(2, Math.floor(Math.log2(zoom / 40)));
                } 
                // Low Zoom (< 40px/m): Decimal steps (1, 2, 5, 10...) for overview
                else {
                    const minPixelSpacing = 50; // Ensure lines are at least 50px apart
                    const rawStep = minPixelSpacing / zoom;
                    const magnitude = Math.pow(10, Math.floor(Math.log10(rawStep)));
                    const residual = rawStep / magnitude;
                    
                    if (residual > 5) return 10 * magnitude;
                    if (residual > 2) return 5 * magnitude;
                    if (residual > 1) return 2 * magnitude;
                    return magnitude;
                }
            }, [zoom]);

            // ... after gridStep useMemo ...

            // ADDED: Pre-calculate diagram points and global scaling statistics
            const plotData = useMemo(() => {
                if (!results) return null;
                
                let maxM = 0; let maxV = 0; let maxA = 0; let maxD = 0;
                
                const diagrams = elements.map(el => {
                    const res = results.memberForces.find(f => f.id === el.id);
                    if (!res) return null;

                    const n1 = nodes[el.n1], n2 = nodes[el.n2];
                    const dx = n2.x - n1.x, dy = n2.y - n1.y;
                    const L = Math.sqrt(dx*dx + dy*dy);
                    
                    const pts = [];
                    const steps = 40; // Increased resolution for partial loads
                    
                    for (let i = 0; i <= steps; i++) {
                        const t = i / steps;
                        const x = t * L;
                        
                        // USE THE NEW INTEGRATOR HERE
                        const vals = getBeamValues(el, x, L);
                        const { mx, vx, ax, disp } = vals;
                        
                        // Simple linear interpolation for reference line (to subtract from disp)
                        // This isolates the "curve" from the rigid body motion
                        const v1 = res.dispLocal[1];
                        const v2 = res.dispLocal[4];
                        const v_linear = v1 * (1-t) + v2 * t;
                        const v_disp = disp - v_linear;

                        if (Math.abs(mx) > maxM) maxM = Math.abs(mx);
                        if (Math.abs(vx) > maxV) maxV = Math.abs(vx);
                        if (Math.abs(ax) > maxA) maxA = Math.abs(ax);
                        if (Math.abs(v_disp) > maxD) maxD = Math.abs(v_disp);

                        pts.push({ t, mx, vx, ax, v_disp });
                    }
                    return { id: el.id, pts };
                });

                return { 
                    diagrams, 
                    stats: { maxM, maxV, maxA, maxD },
                    scales: {
                        m: maxM > 1e-6 ? 1.5 / maxM : 1, 
                        v: maxV > 1e-6 ? 1.5 / maxV : 1,
                        a: maxA > 1e-6 ? 1.5 / maxA : 1,
                        d: maxD > 1e-6 ? 1.0 / maxD : 100
                    }
                };
            }, [results, elements, nodes, loads]);

            const toScreen = (x, y) => ({ x: pan.x + x * zoom, y: pan.y - y * zoom });
            const toWorld = (sx, sy) => ({ x: (sx - pan.x) / zoom, y: (pan.y - sy) / zoom });
            useEffect(() => { draw(); }, [draw, selectedLoad]);
            const draw = useCallback(() => {
                const canvas = canvasRef.current;
                if (!canvas) return;
                const ctx = canvas.getContext('2d');
                // HELPER: Draw Arrowhead
                const drawArrowHead = (x, y, angle, color) => {
                    ctx.save();
                    ctx.translate(x, y);
                    ctx.rotate(angle);
                    ctx.fillStyle = color;
                    ctx.beginPath();
                    ctx.moveTo(0, 0);
                    ctx.lineTo(-6, -3);
                    ctx.lineTo(-6, 3);
                    ctx.closePath();
                    ctx.fill();
                    ctx.restore();
                };
                const w = canvas.width, h = canvas.height;

                // Theme Colors - Professional Engineering Palette
                const colors = isDarkMode ? {
                    // Dark Mode: Deep Blueprint
                    bg: '#0f172a',      // Slate-900
                    grid: '#1e293b',    // Slate-800
                    gridText: '#475569',// Slate-600
                    element: '#94a3b8', // Slate-400 (Light Grey for contrast)
                    node: '#e2e8f0',    // Slate-200
                    text: '#e2e8f0',    // Slate-200
                    dimText: '#64748b', // Slate-500
                    accent: '#38bdf8'   // Sky-400
                } : {
                    // Light Mode: Clean Paper / CAD Style
                    bg: '#ffffff',      // Pure White
                    grid: '#e2e8f0',    // Slate-200 (Subtle)
                    gridText: '#94a3b8',// Slate-400
                    element: '#334155', // Slate-700 (Dark architectural grey lines)
                    node: '#0f172a',    // Slate-900 (High contrast points)
                    text: '#0f172a',    // Slate-900 (Sharp text)
                    dimText: '#64748b', // Slate-500
                    accent: '#2563eb'   // Blue-600
                };
                
                // Professional Font Stack
                const font = `${textSize}px "Inter", "Segoe UI", Roboto, Helvetica, Arial, sans-serif`;
                const fontBold = `bold ${textSize}px "Inter", "Segoe UI", Roboto, Helvetica, Arial, sans-serif`;

                // Clear & Grid
                ctx.fillStyle = colors.bg; ctx.fillRect(0, 0, w, h);
                
                // Draw Grid
                ctx.strokeStyle = colors.grid; 
                ctx.lineWidth = isDarkMode ? 1 : 0.5; // Thinner lines in light mode for elegance
                ctx.beginPath();

                const startX = Math.floor((-pan.x / zoom) / gridStep);
                const endX = Math.floor(((w - pan.x) / zoom) / gridStep) + 1;
                const startY = Math.floor(((pan.y - h) / zoom) / gridStep);
                const endY = Math.floor((pan.y / zoom) / gridStep) + 1;

                // Setup Font for Axis Labels
                ctx.font = font; 
                ctx.textAlign = 'left'; 
                ctx.textBaseline = 'top';

                for (let i = startX; i <= endX; i++) { 
                    const val = i * gridStep;
                    const p = toScreen(val, 0); 
                    ctx.moveTo(p.x, 0); ctx.lineTo(p.x, h);
                    if (i % 2 === 0) { 
                        ctx.fillStyle = colors.gridText; 
                        ctx.fillText(val.toFixed(3).replace(/\.?0+$/, '') + 'm', p.x + 2, h - (textSize + 5)); 
                    }
                }
                for (let i = startY; i <= endY; i++) { 
                    const val = i * gridStep;
                    const p = toScreen(0, val); 
                    ctx.moveTo(0, p.y); ctx.lineTo(w, p.y);
                    if (i % 2 === 0) { 
                        ctx.fillStyle = colors.gridText; 
                        ctx.fillText(val.toFixed(3).replace(/\.?0+$/, '') + 'm', 5, p.y + 2); 
                    }
                }
                ctx.stroke();

                // Origin Marker
                const origin = toScreen(0,0);
                ctx.fillStyle = colors.accent; ctx.beginPath(); ctx.arc(origin.x, origin.y, 3, 0, 2*Math.PI); ctx.fill();
                // Elements
                elements.forEach(el => {
                    const n1 = nodes[el.n1], n2 = nodes[el.n2];
                    const p1 = toScreen(n1.x, n1.y), p2 = toScreen(n2.x, n2.y);
                    let drawP1 = p1, drawP2 = p2;
                    
                    if (results && viewSettings.showDeformed) {
                        const s = viewSettings.defScale;
                        const d1x = results.displacements[3*el.n1] * s, d1y = results.displacements[3*el.n1+1] * s;
                        const d2x = results.displacements[3*el.n2] * s, d2y = results.displacements[3*el.n2+1] * s;
                        drawP1 = toScreen(n1.x + d1x, n1.y + d1y);
                        drawP2 = toScreen(n2.x + d2x, n2.y + d2y);
                        ctx.strokeStyle = '#334155'; ctx.setLineDash([5, 5]);
                        ctx.beginPath(); ctx.moveTo(p1.x, p1.y); ctx.lineTo(p2.x, p2.y); ctx.stroke(); ctx.setLineDash([]);
                    }
                    // DRAW TRUSS AXIAL LABEL
                    if (results && el.type === 'truss') {
                        const res = results.memberForces.find(f => f.id === el.id);
                        if (res && Math.abs(res.axial) > 0.01) {
                            const midX = (drawP1.x + drawP2.x) / 2;
                            const midY = (drawP1.y + drawP2.y) / 2;
                            const dx = drawP2.x - drawP1.x;
                            const dy = drawP2.y - drawP1.y;
                            let angle = Math.atan2(dy, dx);

                            // Keep text upright
                            if (angle > Math.PI / 2 || angle < -Math.PI / 2) {
                                angle += Math.PI;
                            }

                            ctx.save();
                            ctx.translate(midX, midY);
                            ctx.rotate(angle);
                            
                            // Text Style
                            ctx.fillStyle = '#ffffff'; 
                            ctx.font = `bold ${textSize}px monospace`;
                            ctx.textAlign = 'center';
                            ctx.textBaseline = 'bottom';
                            
                            // Shadow for contrast
                            ctx.shadowColor = isDarkMode ? '#000' : '#fff'; 
                            ctx.shadowBlur = 4; 
                            ctx.fillText(`${res.axial.toFixed(2)}kN`, 0, -4);
                            
                            ctx.restore();
                        }
                    }

                    // Element Selection Highlight
                    if (selectedElement === el.id) {
                        ctx.shadowColor = '#3b82f6'; ctx.shadowBlur = 10; ctx.strokeStyle = '#60a5fa'; ctx.lineWidth = 5;
                        ctx.beginPath(); ctx.moveTo(drawP1.x, drawP1.y); ctx.lineTo(drawP2.x, drawP2.y); ctx.stroke();
                        ctx.shadowBlur = 0;
                    }

                    // Style based on Type & Results
                    // Element Style
                    let strokeColor = colors.element; // Use the theme color by default
                    
                    if (results && el.type === 'truss') {
                        // ... (Keep existing Truss Tension/Compression color logic, it is already good) ...
                        const res = results.memberForces.find(f => f.id === el.id);
                        if (res) {
                            const val = res.axial;
                            const maxA = (plotData && plotData.stats && plotData.stats.maxA > 0.1) ? plotData.stats.maxA : 1; 
                            const ratio = Math.min(1, Math.abs(val) / maxA);

                            if (Math.abs(val) < 0.001) {
                                strokeColor = isDarkMode ? '#475569' : '#cbd5e1'; // Neutral for zero force
                            } else if (val > 0) {
                                // Tension (Blue)
                                strokeColor = isDarkMode ? `rgb(${Math.round(59 + 100*ratio)}, ${Math.round(130 + 50*ratio)}, 255)` : '#2563eb';
                            } else {
                                // Compression (Red)
                                strokeColor = isDarkMode ? `rgb(255, ${Math.round(68 + 100*ratio)}, ${Math.round(68 + 100*ratio)})` : '#dc2626';
                            }
                        }
                    }

                    ctx.strokeStyle = strokeColor;
                    ctx.lineWidth = isDarkMode ? 3 : 2.5; // Slightly finer lines in light mode for precision
                    ctx.lineCap = 'round'; // Smooth ends
                    ctx.lineJoin = 'round';
                    ctx.beginPath();

                    // MODIFY: Draw Curved Shape if Deformed is ON and data exists
                    if (viewSettings.showDeformed && plotData && el.type !== 'truss') {
                        const d = plotData.diagrams.find(entry => entry && entry.id === el.id);
                        if (d) {
                            ctx.moveTo(drawP1.x, drawP1.y);
                            const dx = drawP2.x - drawP1.x, dy = drawP2.y - drawP1.y;
                            const L_scr = Math.sqrt(dx*dx + dy*dy);
                            
                            // Calculate base Normal Vector
                            let nx = -dy / L_scr;
                            let ny = dx / L_scr;

                            // FLIP FOR COLUMNS ONLY: 
                            // If element is predominantly vertical (dy > dx), invert the normal.
                            // This fixes the Left/Right direction for columns without affecting the Beams.
                            if (Math.abs(dy) > Math.abs(dx)) {
                                nx = nx;
                                ny = ny;
                            }
                            
                            const s = viewSettings.defScale;

                            d.pts.forEach(pt => {
                                // v_disp is in meters. Convert to pixels (zoom). Scale by defScale (s).
                                // MODIFY: Added negative sign (-) to 'pt.v_disp' to flip the diagram
                                const off = -pt.v_disp * s * zoom; 
                                ctx.lineTo(drawP1.x + pt.t * dx + nx * off, drawP1.y + pt.t * dy + ny * off);
                            });
                            ctx.lineTo(drawP2.x, drawP2.y);
                        } else {
                             ctx.moveTo(drawP1.x, drawP1.y); ctx.lineTo(drawP2.x, drawP2.y);
                        }
                    } else {
                        // Standard straight line
                        ctx.moveTo(drawP1.x, drawP1.y); ctx.lineTo(drawP2.x, drawP2.y);
                    }
                    ctx.stroke();

                    // DRAW HINGES IF TRUSS
                    if (el.type === 'truss') {
                        const dx = drawP2.x - drawP1.x;
                        const dy = drawP2.y - drawP1.y;
                        const len = Math.sqrt(dx*dx + dy*dy);
                        if(len > 15) { // Only draw hinges if beam is long enough
                            const ux = dx/len, uy = dy/len;
                            const r = 3; // Hinge radius
                            const offset = 6;
                            
                            // Hinge near Node 1
                            ctx.fillStyle = '#0f172a'; ctx.strokeStyle = '#cbd5e1'; ctx.lineWidth = 1;
                            ctx.beginPath(); ctx.arc(drawP1.x + ux*offset, drawP1.y + uy*offset, r, 0, 2*Math.PI); ctx.fill(); ctx.stroke();
                            
                            // Hinge near Node 2
                            ctx.beginPath(); ctx.arc(drawP2.x - ux*offset, drawP2.y - uy*offset, r, 0, 2*Math.PI); ctx.fill(); ctx.stroke();
                        }
                    }

                    // Element Loads (Point Span & Distributed)
                    const elLoads = loads.filter(l => (l.type === 'dist' || l.type === 'point_span') && l.elementId === el.id);
                    
                    elLoads.forEach(l => {
                        const isSelected = selectedLoad !== null && loads[selectedLoad] === l;
                        
                        // Style Config
                        const baseColor = isSelected ? '#f87171' : '#facc15'; // Bright Red vs Yellow
                        const distColor = isSelected ? '#f87171' : '#eab308';
                        const fillColor = isSelected ? 'rgba(248, 113, 113, 0.3)' : 'rgba(234, 179, 8, 0.2)';

                        ctx.save(); // Isolate styles
                        if (isSelected) {
                            ctx.shadowColor = baseColor;
                            ctx.shadowBlur = 15; // Glow effect
                            ctx.lineWidth = 3;
                        } else {
                            ctx.lineWidth = 1; // Reset width for non-selected
                        }

                        const dx = drawP2.x - drawP1.x, dy = drawP2.y - drawP1.y;
                        const len_scr = Math.sqrt(dx*dx + dy*dy); 
                        const n1 = nodes[el.n1], n2 = nodes[el.n2];
                        const L_phys = Math.sqrt((n2.x - n1.x)**2 + (n2.y - n1.y)**2);
                        const dir = 1;
                        
                        if (l.type === 'point_span') {
                            const dist = parseFloat(l.dist !== undefined ? l.dist : L_phys/2);
                            const t = dist / L_phys;
                            const px = drawP1.x + t * dx;
                            const py = drawP1.y + t * dy;
                            
                            const mag = parseFloat(l.mag || 10);
                            let ang = (parseFloat(l.angle !== undefined ? l.angle : -90) * Math.PI) / 180;
                            if (l.angleRef === 'local') {
                                const beamAngWorld = Math.atan2(n2.y - n1.y, n2.x - n1.x);
                                ang += beamAngWorld;
                            }
                            const scrAng = -ang; 
                            const arrowLen = 20;
                            const tax = px - dir * Math.cos(scrAng) * arrowLen;
                            const tay = py - dir * Math.sin(scrAng) * arrowLen;
                            
                            ctx.strokeStyle = baseColor; ctx.fillStyle = baseColor;
                            
                            ctx.beginPath(); ctx.moveTo(tax, tay); ctx.lineTo(px, py); ctx.stroke();
                            drawArrowHead(px, py, Math.atan2(py - tay, px - tax), baseColor);
                            
                            ctx.fillStyle = '#fef08a'; 
                            ctx.fillText(`${mag}kN`, tax, tay - (textSize * 0.5));
                        }
                        else if (l.type === 'dist') {
                            const raw_d1 = parseFloat(l.dStart || 0);
                            const raw_d2 = parseFloat(l.dEnd !== undefined ? l.dEnd : L_phys);
                            const d1 = Math.max(0, Math.min(L_phys, raw_d1));
                            const d2 = Math.max(0, Math.min(L_phys, raw_d2));
                            
                            const w1 = parseFloat(l.wStart || 0);
                            const w2 = parseFloat(l.wEnd !== undefined ? l.wEnd : w1);
                            
                            const t1 = d1 / L_phys;
                            const t2 = d2 / L_phys;
                            
                            const pStart = { x: drawP1.x + t1*dx, y: drawP1.y + t1*dy };
                            const pEnd = { x: drawP1.x + t2*dx, y: drawP1.y + t2*dy };
                            
                            let ang = (parseFloat(l.angle !== undefined ? l.angle : -90) * Math.PI) / 180;
                            if (l.angleRef === 'local') {
                                const beamAngWorld = Math.atan2(n2.y - n1.y, n2.x - n1.x);
                                ang += beamAngWorld;
                            }
                            const scrAng = -ang; 
                            const nx = Math.cos(scrAng), ny = Math.sin(scrAng);
                            const scale = 2;  
                            
                            const p1_base = pStart;
                            const p2_base = pEnd;
                            const p2_tip = { x: pEnd.x - dir * nx * w2 * scale, y: pEnd.y - dir * ny * w2 * scale }; 
                            const p1_tip = { x: pStart.x - dir * nx * w1 * scale, y: pStart.y - dir * ny * w1 * scale };
                            
                            ctx.fillStyle = fillColor;
                            ctx.strokeStyle = distColor;
                            
                            ctx.beginPath();
                            ctx.moveTo(p1_base.x, p1_base.y);
                            ctx.lineTo(p2_base.x, p2_base.y);
                            ctx.lineTo(p2_tip.x, p2_tip.y);
                            ctx.lineTo(p1_tip.x, p1_tip.y);
                            ctx.closePath();
                            ctx.fill(); ctx.stroke();

                            ctx.fillStyle = '#fef08a'; 
                            ctx.fillText(`${w1}kN/m`, p1_tip.x, p1_tip.y - (textSize * 0.6));
                            if(Math.abs(w1 - w2) > 0.01) ctx.fillText(`${w2}kN/m`, p2_tip.x, p2_tip.y - (textSize * 0.6));
                            
                            const count = Math.max(2, Math.floor((t2-t1) * len_scr / 15));
                            for(let i=0; i<=count; i++) {
                                const s = i/count;
                                const tx = p1_base.x + s*(p2_base.x - p1_base.x);
                                const ty = p1_base.y + s*(p2_base.y - p1_base.y);
                                const mag = w1*(1-s) + w2*s;
                                const bx = tx - dir * nx * mag * scale;
                                const by = ty - dir * ny * mag * scale;
                                
                                ctx.beginPath(); ctx.moveTo(bx, by); ctx.lineTo(tx, ty); ctx.stroke();
                                drawArrowHead(tx, ty, Math.atan2(ty - by, tx - bx), distColor);
                            }
                        }
                        ctx.restore(); // Restore context
                    });

                    // Results Diagrams (Global Scaled)
                    if (plotData) {
                        const d = plotData.diagrams.find(d => d && d.id === el.id);
                        if (d && d.pts.length > 0) {
                            const dx = drawP2.x - drawP1.x, dy = drawP2.y - drawP1.y;
                            const L_scr = Math.sqrt(dx*dx + dy*dy);
                            const nx = -dy / L_scr, ny = dx / L_scr; // Normal vector

                            // Helper to draw diagram value text
                            const drawLabel = (t, val, unit, offsetPx, color, prefix = '') => {
                                if (Math.abs(val) < 0.01) return; 
                                const lx = drawP1.x + t * dx + nx * offsetPx;
                                const ly = drawP1.y + t * dy + ny * offsetPx;
                                
                                // Text Background for readability
                                ctx.font = fontBold; // Use bold font
                                const text = `${prefix}${val.toFixed(2)}${unit}`;
                                const metrics = ctx.measureText(text);
                                
                                // Optional: Small background box for text in busy areas
                                ctx.fillStyle = isDarkMode ? 'rgba(15, 23, 42, 0.7)' : 'rgba(255, 255, 255, 0.8)';
                                const pad = 2;
                                ctx.fillRect(lx + pad, ly - pad - textSize, metrics.width + pad*2, textSize + pad*2);

                                ctx.fillStyle = color; 
                                ctx.fillText(text, lx + pad*2, ly - pad);
                                
                                ctx.beginPath(); ctx.arc(lx, ly, 2, 0, 2*Math.PI); ctx.fill();
                            };

                            // Draw BMD
                            if (viewSettings.showBMD && el.type !== 'truss') {
                                const scale = plotData.scales.m * viewSettings.diaScale * 40; 
                                ctx.fillStyle = 'rgba(239, 68, 68, 0.2)'; ctx.strokeStyle = '#ef4444'; ctx.lineWidth = 1;
                                ctx.beginPath(); ctx.moveTo(drawP1.x, drawP1.y);
                                
                                let maxVal = 0, maxT = 0, maxOff = 0;

                                d.pts.forEach(pt => {
                                    // [MODIFY] Removed negative sign (-) to flip diagram
                                    const off = pt.mx * scale; 
                                    if(Math.abs(pt.mx) > Math.abs(maxVal)) { maxVal = pt.mx; maxT = pt.t; maxOff = off; }
                                    ctx.lineTo(drawP1.x + pt.t*dx + nx*off, drawP1.y + pt.t*dy + ny*off);
                                });
                                ctx.lineTo(drawP2.x, drawP2.y); ctx.closePath(); ctx.fill(); ctx.stroke();

                                // [MODIFY] Updated labels to match new positive direction
                                drawLabel(0, d.pts[0].mx, 'kNm', d.pts[0].mx*scale, '#fca5a5'); // Start
                                drawLabel(1, d.pts[d.pts.length-1].mx, 'kNm', d.pts[d.pts.length-1].mx*scale, '#fca5a5'); // End
                                if(maxT > 0.05 && maxT < 0.95) drawLabel(maxT, maxVal, 'kNm', maxOff, '#ffffff'); // Peak
                            }

                            // Draw SFD
                            if (viewSettings.showSFD && el.type !== 'truss') {
                                const scale = plotData.scales.v * viewSettings.diaScale * 40;
                                ctx.fillStyle = 'rgba(59, 130, 246, 0.2)'; ctx.strokeStyle = '#3b82f6'; ctx.lineWidth = 1;
                                ctx.beginPath(); ctx.moveTo(drawP1.x, drawP1.y);
                                
                                let maxVal = 0, maxT = 0, maxOff = 0;

                                d.pts.forEach(pt => {
                                    // [MODIFY] Added negative sign (-) to flip diagram
                                    const off = -pt.vx * scale;
                                    if(Math.abs(pt.vx) > Math.abs(maxVal)) { maxVal = pt.vx; maxT = pt.t; maxOff = off; }
                                    ctx.lineTo(drawP1.x + pt.t*dx + nx*off, drawP1.y + pt.t*dy + ny*off);
                                });
                                ctx.lineTo(drawP2.x, drawP2.y); ctx.closePath(); ctx.fill(); ctx.stroke();

                                // [MODIFY] Updated labels to match new negative direction
                                drawLabel(0, d.pts[0].vx, 'kN', -d.pts[0].vx*scale, '#93c5fd');
                                drawLabel(1, d.pts[d.pts.length-1].vx, 'kN', -d.pts[d.pts.length-1].vx*scale, '#93c5fd');
                                if(maxT > 0.05 && maxT < 0.95) drawLabel(maxT, maxVal, 'kN', maxOff, '#ffffff');
                            }

                            // Draw AFD
                            if (viewSettings.showAFD) {
                                const scale = plotData.scales.a * viewSettings.diaScale * 40;
                                ctx.fillStyle = 'rgba(236, 72, 153, 0.2)'; ctx.strokeStyle = '#ec4899'; ctx.lineWidth = 1;
                                ctx.beginPath(); ctx.moveTo(drawP1.x, drawP1.y);
                                d.pts.forEach(pt => {
                                    // [MODIFY] Added negative sign (-) to flip diagram
                                    const off = -pt.ax * scale; 
                                    ctx.lineTo(drawP1.x + pt.t*dx + nx*off, drawP1.y + pt.t*dy + ny*off);
                                });
                                ctx.lineTo(drawP2.x, drawP2.y); ctx.closePath(); ctx.fill(); ctx.stroke();
                                
                                // [MODIFY] Updated label to match new negative direction
                                drawLabel(0.5, d.pts[Math.floor(d.pts.length/2)].ax, 'kN', -d.pts[Math.floor(d.pts.length/2)].ax * scale, '#f9a8d4');
                            }
                            
                            // Deformed Max Label
                            if(viewSettings.showDeformed && el.type !== 'truss') {
                                let maxD = 0, maxT = 0;
                                d.pts.forEach(pt => { if(Math.abs(pt.v_disp) > Math.abs(maxD)) { maxD = pt.v_disp; maxT = pt.t; } });
                                if(Math.abs(maxD) > 0.0001) {
                                    const s = viewSettings.defScale;
                                    const off = maxD * s * zoom; 
                                    // MODIFY: Add 'δ: ' prefix to clarify this is deflection
                                    drawLabel(maxT, maxD*1000, 'mm', off, '#34d399', 'δ: ');
                                }
                            }
                        }
                    }
                });

                // Supports
                supports.forEach(sup => {
                    const n = nodes[sup.nodeId];
                    if(!n) return;
                    
                    // MODIFY: Calculate deformed position so support follows the node
                    let p = toScreen(n.x, n.y);
                    if (results && viewSettings.showDeformed) {
                        const s = viewSettings.defScale;
                        // Safe access to displacements
                        const dx = results.displacements[3 * sup.nodeId] || 0;
                        const dy = results.displacements[3 * sup.nodeId + 1] || 0;
                        p = toScreen(n.x + dx * s, n.y + dy * s);
                    }
                    
                    ctx.save();
                    ctx.translate(p.x, p.y);
                    // DRAW REACTIONS
                    if (results && viewSettings.showReactions) {
                        // 1. Find members connected to this support node
                        const connectedMembers = results.memberForces.filter(mf => {
                            const el = elements.find(e => e.id === mf.id);
                            return el.n1 === sup.nodeId || el.n2 === sup.nodeId;
                        });

                        // 2. Sum Global Forces at this node from all connected members
                        // Reaction = Force required to balance the Member Forces (+ External Loads if any, handled by solver usually, but let's stick to member ends)
                        // Equilibrium: Reaction + Sum(F_member_global) = 0  =>  Reaction = -Sum(F_member_global)
                        
                        let rx = 0, ry = 0, rm = 0;
                        
                        connectedMembers.forEach(mf => {
                            const el = elements.find(e => e.id === mf.id);
                            if (el.n1 === sup.nodeId) {
                                // Start Node forces (Indices 0, 1, 2)
                                rx += mf.globalForces[0];
                                ry += mf.globalForces[1];
                                rm += mf.globalForces[2];
                            } else {
                                // End Node forces (Indices 3, 4, 5)
                                rx += mf.globalForces[3];
                                ry += mf.globalForces[4];
                                rm += mf.globalForces[5];
                            }
                        });

                        // 3. Subtract any Applied Nodal Loads at this support (Reaction must oppose them too)
                        const directLoad = loads.find(l => l.type === 'point' && l.nodeId === sup.nodeId);
                        if(directLoad) {
                            // MODIFY: Add load to the Action accumulator (Total Action = Member Force + External Load)
                            rx -= parseFloat(directLoad.fx || 0);
                            ry -= parseFloat(directLoad.fy || 0);
                            rm -= parseFloat(directLoad.m || 0);
                        }

                        // 4. Draw
                        ctx.font = `${textSize}px monospace`;
                        ctx.fillStyle = '#ef4444'; ctx.strokeStyle = '#ef4444';
                        const eps = 0.01;

                        // Rx: Draw to the LEFT (-X direction) relative to node
                        const gap = textSize * 0.8;

                        // Rx
                        if (Math.abs(rx) > eps) {
                            const offset = -45; 
                            const startX = offset;
                            const endX = offset + (rx > 0 ? 15 : -15); 
                            
                            ctx.beginPath(); ctx.moveTo(startX, 0); ctx.lineTo(endX, 0); ctx.stroke();
                            drawArrowHead(endX, 0, rx > 0 ? 0 : Math.PI, '#ef4444');
                            
                            ctx.textAlign = 'right';
                            // Dynamic spacing
                            ctx.fillText(`Rx: ${Math.abs(rx).toFixed(2)}kN`, offset - gap, -(textSize * 0.3));
                            ctx.textAlign = 'left'; 
                        }

                        // Ry
                        if (Math.abs(ry) > eps) {
                            const offset = 45; 
                            const startY = offset;
                            const endY = offset + (ry > 0 ? -15 : 15);

                            ctx.beginPath(); ctx.moveTo(0, startY); ctx.lineTo(0, endY); ctx.stroke();
                            drawArrowHead(0, endY, ry > 0 ? -Math.PI/2 : Math.PI/2, '#ef4444');
                            
                            // Dynamic spacing
                            ctx.fillText(`Ry: ${Math.abs(ry).toFixed(2)}kN`, gap, offset + (textSize * 0.3));
                        }

                        // Moment
                        if (Math.abs(rm) > eps) {
                            const r = 25;
                            // Dynamic spacing from circle
                            ctx.fillText(`Rm: ${Math.abs(rm).toFixed(2)}kNm`, r + gap, -(r + gap));
                            
                            ctx.beginPath(); 
                            ctx.arc(0, 0, r, 0, rm > 0 ? -Math.PI/2 : Math.PI/2, rm > 0); 
                            ctx.stroke();
                            
                            const tipAng = rm > 0 ? -Math.PI/2 : Math.PI/2;
                            drawArrowHead(r*Math.cos(tipAng), r*Math.sin(tipAng), tipAng + (rm>0? -Math.PI/2 : Math.PI/2), '#ef4444');
                        }
                    }
                    // Rotate based on input angle (deg to rad)
                    // -90 adjustment makes 0 degrees = 'floor' (pointing up)
                    ctx.rotate((sup.angle || 0) * Math.PI / 180);

                    ctx.lineWidth = 2;
                    ctx.strokeStyle = '#22c55e'; 
                    ctx.fillStyle = '#0f172a'; // Fill with bg color to cover grid

                    if (sup.rx && sup.ry && sup.rm) { 
                        // FIXED (Block with hashes on back)
                        ctx.beginPath(); ctx.moveTo(0, -10); ctx.lineTo(0, 10); ctx.stroke(); // Surface
                        ctx.beginPath(); // Hashes
                        for(let i=-10; i<=10; i+=5) { ctx.moveTo(0, i); ctx.lineTo(-5, i+3); }
                        ctx.stroke();
                    }
                    else if (sup.rx && sup.ry) { 
                        // PIN (Triangle on surface)
                        ctx.beginPath(); ctx.moveTo(0,0); ctx.lineTo(-8, 14); ctx.lineTo(8, 14); ctx.closePath(); 
                        ctx.fill(); ctx.stroke(); 
                        ctx.beginPath(); ctx.arc(0,0, 2, 0, 2*Math.PI); ctx.stroke(); // Hinge
                        
                        // Surface Line
                        ctx.beginPath(); ctx.moveTo(-14, 14); ctx.lineTo(14, 14); ctx.stroke();
                        // Hashes
                        ctx.beginPath();
                        for(let i=-14; i<=14; i+=5) { ctx.moveTo(i, 14); ctx.lineTo(i-3, 19); }
                        ctx.stroke();
                    }
                    else { 
                        // ROLLER (Triangle -> Gap -> Surface)
                        ctx.beginPath(); ctx.moveTo(0,0); ctx.lineTo(-8, 12); ctx.lineTo(8, 12); ctx.closePath(); 
                        ctx.fill(); ctx.stroke();
                        ctx.beginPath(); ctx.arc(0,0, 2, 0, 2*Math.PI); ctx.stroke(); // Hinge
                        
                        // Surface Line (Gap)
                        ctx.beginPath(); ctx.moveTo(-14, 16); ctx.lineTo(14, 16); ctx.stroke();
                        // Hashes
                        ctx.beginPath();
                        for(let i=-14; i<=14; i+=5) { ctx.moveTo(i, 16); ctx.lineTo(i-3, 21); }
                        ctx.stroke();
                    }
                    ctx.restore();
                });

                // Nodes
                nodes.forEach((n, i) => {
                    let p = toScreen(n.x, n.y);
                    if (results && viewSettings.showDeformed) {
                        const s = viewSettings.defScale;
                        p = toScreen(n.x + results.displacements[3*i]*s, n.y + results.displacements[3*i+1]*s);
                    }
                    
                    // Node Circle
                    ctx.beginPath(); ctx.arc(p.x, p.y, 3.5, 0, 2*Math.PI); 
                    if (selectedNode === i) { 
                        ctx.fillStyle = colors.accent; ctx.fill(); 
                        ctx.strokeStyle = isDarkMode ? '#fff' : '#000'; ctx.lineWidth = 2; ctx.stroke(); 
                        // Selection Halo
                        ctx.beginPath(); ctx.arc(p.x, p.y, 8, 0, 2*Math.PI); 
                        ctx.strokeStyle = colors.accent; ctx.lineWidth = 1; ctx.stroke(); 
                    } else { 
                        ctx.fillStyle = colors.node; ctx.fill(); 
                    }
                    
                    // Node Label
                    ctx.fillStyle = colors.dimText; 
                    ctx.font = font; // Use new font variable
                    ctx.fillText(i, p.x + 6, p.y - 6);
                    // Helper for arrowheads
                    const drawArrowHead = (x, y, angle, color) => {
                        ctx.save();
                        ctx.translate(x, y);
                        ctx.rotate(angle);
                        ctx.fillStyle = color;
                        ctx.beginPath();
                        ctx.moveTo(0, 0);
                        ctx.lineTo(-6, -3);
                        ctx.lineTo(-6, 3);
                        ctx.closePath();
                        ctx.fill();
                        ctx.restore();
                    };

                    // Draw Loads attached to nodes
                    const nodeLoads = loads.filter(l => (!l.type || l.type === 'point' || l.type === 'settlement') && l.nodeId === i);
                    nodeLoads.forEach(l => {
                        const isSelected = selectedLoad !== null && loads[selectedLoad] === l;
                        // Select color: Settlement (Purple) vs Force (Yellow) vs Selected (Bright Red)
                        const color = isSelected ? '#f87171' : (l.type === 'settlement' ? '#a855f7' : '#eab308');

                        ctx.save();
                        if (isSelected) {
                            ctx.shadowColor = color;
                            ctx.shadowBlur = 15;
                            ctx.lineWidth = 3;
                        }

                        ctx.strokeStyle = color; ctx.fillStyle = color;
                        const arrowScale = 2;
                        const gap = textSize * 0.6;
                        
                        if(l.type === 'settlement') {
                            let txt = "SETT: ";
                            if(l.dx) txt += `dx=${l.dx}m `;
                            if(l.dy) txt += `dy=${l.dy}m `;
                            ctx.fillText(txt, p.x - (textSize * 2), p.y + (textSize + 10));
                        } else {
                            if (l.fx != 0) { 
                                const tipX = p.x + l.fx*arrowScale;
                                ctx.beginPath(); ctx.moveTo(p.x, p.y); ctx.lineTo(tipX, p.y); ctx.stroke(); 
                                drawArrowHead(tipX, p.y, l.fx > 0 ? 0 : Math.PI, color);
                                const txtOff = l.fx > 0 ? gap : -(textSize * 4); 
                                ctx.fillText(`${l.fx}kN`, tipX + txtOff, p.y + (textSize * 0.3));
                            }
                            if (l.fy != 0) { 
                                const tipY = p.y - l.fy*arrowScale;
                                ctx.beginPath(); ctx.moveTo(p.x, p.y); ctx.lineTo(p.x, tipY); ctx.stroke(); 
                                drawArrowHead(p.x, tipY, l.fy > 0 ? -Math.PI/2 : Math.PI/2, color);
                                ctx.fillText(`${l.fy}kN`, p.x + gap, tipY + (textSize * 0.3));
                            }
                            if (l.m != 0) {
                                ctx.fillText(`${l.m}kNm`, p.x + (textSize), p.y - (textSize));
                                ctx.beginPath(); ctx.arc(p.x, p.y, 12, 0, l.m > 0 ? -Math.PI/2 : Math.PI/2, l.m > 0); ctx.stroke();
                                const tipAng = l.m > 0 ? -Math.PI/2 : Math.PI/2;
                                drawArrowHead(p.x + 12*Math.cos(tipAng), p.y + 12*Math.sin(tipAng), tipAng + (l.m>0? -Math.PI/2 : Math.PI/2), color);
                            }
                        }
                        ctx.restore();
                    });
                });

                // ADDED: Hover Indicator
                if (hoverData) {
                    const el = elements.find(e => e.id === hoverData.elId);
                    if (el) {
                        const n1 = nodes[el.n1], n2 = nodes[el.n2];
                        const p1 = toScreen(n1.x, n1.y), p2 = toScreen(n2.x, n2.y);
                        // Interpolate position based on x_loc
                        const L_phys = Math.sqrt((n2.x - n1.x)**2 + (n2.y - n1.y)**2);
                        const t = hoverData.x_loc / L_phys;
                        const hx = p1.x + t * (p2.x - p1.x);
                        const hy = p1.y + t * (p2.y - p1.y);
                        
                        ctx.fillStyle = '#ffffff'; 
                        ctx.beginPath(); ctx.arc(hx, hy, 4, 0, 2*Math.PI); ctx.fill();
                        ctx.strokeStyle = '#000000'; ctx.lineWidth = 1; ctx.stroke();
                    }
                }

                // Ghost Node & Band
                if (tool === 'node' && !isDragging) {
                    const worldM = toWorld(mousePos.x, mousePos.y);
                    const snapX = Math.round(worldM.x / gridStep) * gridStep;
                    const snapY = Math.round(worldM.y / gridStep) * gridStep;
                    const p = toScreen(snapX, snapY);
                    
                    ctx.globalAlpha = 0.5; ctx.fillStyle = '#3b82f6'; ctx.beginPath(); ctx.arc(p.x, p.y, 4, 0, 2*Math.PI); ctx.fill(); ctx.globalAlpha = 1.0;
                    ctx.fillStyle = '#cbd5e1'; ctx.fillText(`(${snapX.toFixed(3)}, ${snapY.toFixed(3)})`, p.x + 10, p.y - 10);
                }
                if (tool === 'element' && selectedNode !== null) {
                    const n = nodes[selectedNode];
                    const p1 = toScreen(n.x, n.y);
                    const worldM = toWorld(mousePos.x, mousePos.y);
                    const snapX = Math.round(worldM.x / gridStep) * gridStep;
                    const snapY = Math.round(worldM.y / gridStep) * gridStep;
                    const p2 = toScreen(snapX, snapY);
                    
                    ctx.strokeStyle = '#60a5fa'; ctx.setLineDash([4, 4]); ctx.beginPath(); ctx.moveTo(p1.x, p1.y); ctx.lineTo(p2.x, p2.y); ctx.stroke(); ctx.setLineDash([]);
                }

            // MODIFY: Added 'textSize' to dependencies so it redraws immediately
            }, [nodes, elements, supports, loads, results, pan, zoom, viewSettings, tool, selectedNode, selectedElement, selectedLoad, mousePos, textSize]); // <--- ADD selectedLoad HERE

            // Interaction Handlers
            // Interaction Handlers
            const handleWheel = (e) => setZoom(Math.max(5, zoom - e.deltaY * 0.1));
            
            const handleMouseDown = (e) => {
                const rect = canvasRef.current.getBoundingClientRect();
                // Handle touch or mouse event
                const clientX = e.touches ? e.touches[0].clientX : e.clientX;
                const clientY = e.touches ? e.touches[0].clientY : e.clientY;
                setDragStart({ x: clientX - rect.left, y: clientY - rect.top });
                setIsDragging(true);
            };

            const handlePointerMove = (clientX, clientY) => {
                const rect = canvasRef.current.getBoundingClientRect();
                const sx = clientX - rect.left, sy = clientY - rect.top;
                setMousePos({ x: sx, y: sy });

                if (isDragging) {
                    setPan(p => ({ x: p.x + (sx - dragStart.x), y: p.y + (sy - dragStart.y) }));
                    setDragStart({ x: sx, y: sy });
                    setHoverData(null); 
                    return;
                }

                // Hover Detection
                if (results && plotData) {
                    let closest = null;
                    let minDst = 20; 

                    elements.forEach(el => {
                        const n1 = nodes[el.n1], n2 = nodes[el.n2];
                        const p1 = toScreen(n1.x, n1.y), p2 = toScreen(n2.x, n2.y);
                        
                        const dx = p2.x - p1.x, dy = p2.y - p1.y;
                        const lenSq = dx*dx + dy*dy;
                        if(lenSq === 0) return;
                        
                        const t = Math.max(0, Math.min(1, ((sx - p1.x)*dx + (sy - p1.y)*dy) / lenSq));
                        const projX = p1.x + t * dx;
                        const projY = p1.y + t * dy;
                        const dst = Math.sqrt((sx - projX)**2 + (sy - projY)**2);

                        if (dst < minDst) {
                            minDst = dst;
                            const L_phys = Math.sqrt((n2.x - n1.x)**2 + (n2.y - n1.y)**2);
                            const x_local = t * L_phys;
                            const vals = getBeamValues(el, x_local, L_phys);
                            
                            const d = plotData.diagrams.find(d => d.id === el.id);
                            let stats = { maxM: 0, minM: 0, maxV: 0, minV: 0, maxA: 0, minA: 0 };
                            
                            if(d && d.pts.length > 0) {
                                stats.maxM = Math.max(...d.pts.map(p => p.mx));
                                stats.minM = Math.min(...d.pts.map(p => p.mx));
                                stats.maxV = Math.max(...d.pts.map(p => p.vx));
                                stats.minV = Math.min(...d.pts.map(p => p.vx));
                                stats.maxA = Math.max(...d.pts.map(p => p.ax));
                                stats.minA = Math.min(...d.pts.map(p => p.ax));
                            }

                            closest = { 
                                x: sx, y: sy, 
                                elId: el.id, x_loc: x_local, ...vals,
                                ...stats
                            };
                        }
                    });
                    setHoverData(closest);
                }
            };

            const handleMouseMove = (e) => handlePointerMove(e.clientX, e.clientY);
            
            const handleTouchMove = (e) => { 
                if(!isDragging && hoverData) e.preventDefault(); 
                handlePointerMove(e.touches[0].clientX, e.touches[0].clientY); 
            };
            const handleMouseUp = (e) => {
                setIsDragging(false);
                const rect = canvasRef.current.getBoundingClientRect();
                const sx = e.clientX - rect.left, sy = e.clientY - rect.top;
                const worldPos = toWorld(sx, sy);

                // Snap to grid
                const snappedPos = {
                    x: Math.round(worldPos.x / gridStep) * gridStep,
                    y: Math.round(worldPos.y / gridStep) * gridStep
                };
                
                // 1. Hit Test Nodes (Priority)
                let clickedNodeId = null;
                nodes.forEach((n, i) => {
                    const p = toScreen(n.x, n.y);
                    // Radius 15px for comfortable clicking
                    if (Math.sqrt(Math.pow(sx - p.x, 2) + Math.pow(sy - p.y, 2)) < 15) clickedNodeId = i;
                });

                // 2. Hit Test Elements
                let clickedElementId = null;
                if (clickedNodeId === null) {
                    let minElDist = 20; // Increased tolerance (was 10)
                    
                    elements.forEach(el => {
                        const n1 = nodes[el.n1];
                        const n2 = nodes[el.n2];
                        const p1 = toScreen(n1.x, n1.y);
                        const p2 = toScreen(n2.x, n2.y);
                        
                        // A. Calculate distance to STRAIGHT Line (Baseline)
                        let dist = Infinity;
                        const dx = p2.x - p1.x;
                        const dy = p2.y - p1.y;
                        const len_sq = dx*dx + dy*dy;

                        if (len_sq > 0) {
                            const t = ((sx - p1.x) * dx + (sy - p1.y) * dy) / len_sq;
                            let xx, yy;
                            if (t < 0) { xx = p1.x; yy = p1.y; }
                            else if (t > 1) { xx = p2.x; yy = p2.y; }
                            else { xx = p1.x + t * dx; yy = p1.y + t * dy; }
                            dist = Math.sqrt((sx - xx)**2 + (sy - yy)**2);
                        }

                        // B. If Deformed View is ON, also check distance to the CURVE
                        // This allows clicking the sagging middle of a beam
                        if (viewSettings.showDeformed && plotData && el.type !== 'truss') {
                            const d = plotData.diagrams.find(entry => entry && entry.id === el.id);
                            if (d && d.pts.length > 1) {
                                const s = viewSettings.defScale;
                                const L_scr = Math.sqrt(len_sq);
                                const nx = -dy / L_scr; 
                                const ny = dx / L_scr;

                                // Iterate through polyline segments of the curve
                                for (let k = 0; k < d.pts.length - 1; k++) {
                                    const ptA = d.pts[k];
                                    const ptB = d.pts[k+1];
                                    
                                    // Screen positions of segment points
                                    // Note: Using the same offset logic as 'draw' function
                                    const offA = -ptA.v_disp * s * zoom;
                                    const offB = -ptB.v_disp * s * zoom;
                                    
                                    const ax = p1.x + ptA.t * dx + nx * offA;
                                    const ay = p1.y + ptA.t * dy + ny * offA;
                                    const bx = p1.x + ptB.t * dx + nx * offB;
                                    const by = p1.y + ptB.t * dy + ny * offB;
                                    
                                    // Distance to this short segment
                                    const segDx = bx - ax;
                                    const segDy = by - ay;
                                    const segLenSq = segDx*segDx + segDy*segDy;
                                    
                                    if(segLenSq > 0) {
                                        const segT = Math.max(0, Math.min(1, ((sx - ax)*segDx + (sy - ay)*segDy) / segLenSq));
                                        const segX = ax + segT * segDx;
                                        const segY = ay + segT * segDy;
                                        const segDist = Math.sqrt((sx - segX)**2 + (sy - segY)**2);
                                        
                                        if (segDist < dist) dist = segDist; // Use closest distance found
                                    }
                                }
                            }
                        }

                        if (dist < minElDist) {
                            minElDist = dist;
                            clickedElementId = el.id;
                        }
                    });
                }

                // 3. Hit Test Loads (Arrows/Text)
                let clickedLoadIndex = null;
                if (clickedNodeId === null) {
                    // Reuse same logic from before, but prioritized after nodes
                    loads.forEach((l, index) => {
                        let hit = false;
                        if (l.nodeId !== undefined) {
                            const n = nodes[l.nodeId];
                            if(n) {
                                const p = toScreen(n.x, n.y);
                                if (Math.sqrt((sx - p.x)**2 + (sy - p.y)**2) < 25) hit = true;
                                // Check arrow tips
                                if (l.fx && Math.abs(sx - (p.x + l.fx*2)) < 15 && Math.abs(sy - p.y) < 15) hit = true;
                                if (l.fy && Math.abs(sx - p.x) < 15 && Math.abs(sy - (p.y - l.fy*2)) < 15) hit = true;
                            }
                        } else if (l.elementId !== undefined) {
                            // Simplified: Check if click is near the beam the load is on
                            const el = elements.find(e => e.id === l.elementId);
                            if(el) {
                                const n1 = nodes[el.n1], n2 = nodes[el.n2];
                                const p1 = toScreen(n1.x, n1.y), p2 = toScreen(n2.x, n2.y);
                                const dx = p2.x - p1.x, dy = p2.y - p1.y;
                                const L2 = dx*dx + dy*dy;
                                if(L2 > 0) {
                                    const t = Math.max(0, Math.min(1, ((sx-p1.x)*dx + (sy-p1.y)*dy) / L2));
                                    const px = p1.x + t*dx, py = p1.y + t*dy;
                                    const dist = Math.sqrt((sx-px)**2 + (sy-py)**2);
                                    
                                    // If we clicked near the beam (but not ON the beam, to avoid conflict)
                                    // Or if we clicked near a specific point load location
                                    if (dist > 10 && dist < 40) hit = true; 
                                    
                                    // Point Span specific check
                                    if (l.type === 'point_span') {
                                        const L_phys = Math.sqrt((n2.x - n1.x)**2 + (n2.y - n1.y)**2);
                                        const loadT = (l.dist || L_phys/2) / L_phys;
                                        if (Math.abs(t - loadT) < 0.1 && dist < 40) hit = true;
                                    }
                                }
                            }
                        }
                        if (hit) clickedLoadIndex = index;
                    });
                }

                onCanvasInteract({ type: 'click', worldPos, snappedPos, nodeId: clickedNodeId, elementId: clickedElementId, loadIndex: clickedLoadIndex });
            };

            useEffect(() => {
                const resize = () => {
                    if(canvasRef.current) {
                        canvasRef.current.width = canvasRef.current.parentElement.clientWidth;
                        canvasRef.current.height = canvasRef.current.parentElement.clientHeight;
                        draw();
                    }
                };
                window.addEventListener('resize', resize);
                resize();
                return () => window.removeEventListener('resize', resize);
            }, [draw]);

            useEffect(() => { draw(); }, [draw]);

            return (
                <div className="flex-1 bg-slate-900 relative overflow-hidden h-full select-none">
                    <canvas ref={canvasRef} onWheel={handleWheel} onMouseDown={handleMouseDown} onMouseMove={handleMouseMove} onMouseUp={handleMouseUp} onMouseLeave={() => {setIsDragging(false); setHoverData(null);}} 
                        onTouchMove={handleTouchMove} onTouchStart={handleMouseDown} onTouchEnd={handleMouseUp}
                        className={`absolute inset-0 z-10 ${tool === 'pointer' ? 'cursor-grab' : 'cursor-crosshair'}`}
                        style={{cursor: tool === 'pointer' ? (isDragging ? 'grabbing' : 'grab') : 'crosshair'}}
                    />
                    
                    {/* ADDED: Hover Tooltip */}
                    {hoverData && (
                        <div className="absolute z-30 bg-slate-800/95 border border-slate-500 p-2 rounded shadow-xl text-[10px] pointer-events-none whitespace-nowrap"
                             style={{ left: hoverData.x + 15, top: hoverData.y + 15 }}>
                            <div className="font-bold text-slate-300 border-b border-slate-600 mb-1 pb-1">
                                {t('el_det')} {hoverData.elId} @ {hoverData.x_loc.toFixed(2)}m
                            </div>
                            <div className="grid grid-cols-2 gap-x-3 gap-y-0.5">
                                <span className="text-red-400">{t('moment')}:</span>
                                <span className="font-mono text-right">{hoverData.mx.toFixed(2)} kNm</span>
                                
                                <span className="text-blue-400">{t('shear')}:</span>
                                <span className="font-mono text-right">{hoverData.vx.toFixed(2)} kN</span>

                                <span className="text-pink-400">{t('axial')}:</span>
                                <span className="font-mono text-right">{hoverData.ax.toFixed(2)} kN</span>
                                
                                <span className="text-emerald-400">{t('defl')}:</span>
                                <span className="font-mono text-right">{(hoverData.disp * 1000).toFixed(2)} mm</span>
                            </div>
                            <div className="mt-1 pt-1 border-t border-slate-600 text-slate-400 grid grid-cols-2 gap-x-4">
                                <span className="text-red-300">Max M: {hoverData.maxM.toFixed(1)}</span>
                                <span className="text-red-300">Min M: {hoverData.minM.toFixed(1)}</span>
                                <span className="text-blue-300">Max V: {hoverData.maxV.toFixed(1)}</span>
                                <span className="text-blue-300">Min V: {hoverData.minV.toFixed(1)}</span>
                                <span className="text-pink-300">Max A: {hoverData.maxA.toFixed(1)}</span>
                                <span className="text-pink-300">Min A: {hoverData.minA.toFixed(1)}</span>
                            </div>
                        </div>
                    )}
                    <div className="absolute bottom-4 left-4 z-20 bg-slate-800/80 p-2 rounded text-[10px] text-slate-300 pointer-events-none hidden sm:block">
                        <p>{t('instr_zoom')}</p>
                        <p>{t('mode')}: {tool.toUpperCase()}</p>
                        <p>{tool === 'node' ? t('click_add') : tool === 'element' ? t('click_start') : tool === 'support' ? t('click_node') : tool === 'load' ? t('click_node_inst') : t('select_items')}</p>
                    </div>
                    {/* ADDED: Results Legend */}
                    {results && plotData && (
                        <div className={`absolute bottom-4 right-4 z-20 p-3 rounded text-xs shadow-lg pointer-events-none backdrop-blur-md ${isDarkMode ? 'bg-slate-800/90 text-slate-200 border border-slate-600' : 'bg-white/90 text-gray-700 border border-gray-200'}`}>
                            <h4 className={`font-bold mb-1 border-b pb-1 ${isDarkMode ? 'border-slate-600' : 'border-gray-300'}`}>{t('global_ext')}</h4>
                            {viewSettings.showBMD && (
                                <div className="text-red-500 font-mono">{t('max_m')}: {plotData.stats.maxM.toFixed(2)} kNm</div>
                            )}
                            {viewSettings.showSFD && (
                                <div className="text-blue-500 font-mono">{t('max_v')}: {plotData.stats.maxV.toFixed(2)} kN</div>
                            )}
                            {viewSettings.showAFD && (
                                <div className="text-pink-500 font-mono">{t('max_a')}: {plotData.stats.maxA.toFixed(2)} kN</div>
                            )}
                            {viewSettings.showDeformed && (
                                <div className="text-emerald-600 font-mono">{t('max_d')}: {plotData.stats.maxD.toExponential(2)} m</div>
                            )}
                        </div>
                    )}
                </div>
            );
        };
        // ==========================================
        // TIER 2.5: UI COMPONENTS (MODALS)
        // ==========================================

        const LoadModal = ({ loadConfig, onConfirm, onCancel, isDarkMode, t }) => { 
            // Reuse the professional logic from uiClasses but defined locally for the modal's specific structure
            const inputClass = isDarkMode 
                ? "bg-slate-900/50 border-slate-600 text-slate-200 w-full rounded px-2 py-1.5 text-xs focus:outline-none focus:border-blue-500 border transition-colors" 
                : "bg-gray-50 border-gray-300 text-gray-900 w-full rounded px-2 py-1.5 text-xs focus:outline-none focus:bg-white focus:border-blue-600 focus:ring-1 focus:ring-blue-600 border transition-colors";
            
            const panelClass = isDarkMode 
                ? "bg-slate-800 border-slate-600 text-slate-100 shadow-2xl" 
                : "bg-white border-gray-200 text-gray-800 shadow-2xl";
            // Local state for the inputs
            const [data, setData] = useState({ ...loadConfig });

            // Update local data
            const update = (field, val) => setData(prev => ({ ...prev, [field]: val }));

            return (
                <div className="absolute inset-0 z-50 flex items-center justify-center bg-black/50 backdrop-blur-sm">
                    <div className="bg-slate-800 border border-slate-600 p-4 rounded shadow-2xl w-80">
                        <h3 className="text-sm font-bold mb-3 border-b border-gray-500 pb-2">
                            {t('conf_load')}
                        </h3>
                        
                        <div className="space-y-3 mb-4">
                            {/* Target Info */}
                            <div className="text-xs text-gray-400">
                             {t('target')}: <span className="text-blue-400 font-mono">
                                {data.elementId !== undefined ? `${t('beam')} ${data.elementId}` : `${t('node')} ${data.nodeId}`}
                            </span>
                        </div>

                            {/* NODAL POINT */}
                            {data.type === 'point' && (
                                <>
                                    <div className="grid grid-cols-2 gap-2 mb-2">
                                        <div>
                                            <label className="text-[10px] text-slate-500">Fx (kN)</label>
                                            <input type="number" className={inputClass} value={data.fx} onChange={e=>update('fx', e.target.value)} />
                                        </div>
                                        <div>
                                            <label className="text-[10px] text-slate-500">Fy (kN)</label>
                                            <input type="number" className={inputClass} value={data.fy} onChange={e=>update('fy', e.target.value)} />
                                        </div>
                                    </div>
                                    <div>
                                        <label className="text-[10px] text-slate-500">{t('moment')} (kNm)</label>
                                        <input type="number" className={inputClass} value={data.m} onChange={e=>update('m', e.target.value)} />
                                    </div>
                                </>
                            )}

                            {/* BEAM POINT */}
                            {data.type === 'point_span' && (
                                <>
                                    <div className="grid grid-cols-2 gap-2 mb-2">
                                        <div>
                                            <label className="text-[10px] text-slate-500">{t('mag')} (kN)</label>
                                            <input type="number" className={inputClass} value={data.mag} onChange={e=>update('mag', e.target.value)} />
                                        </div>
                                        <div>
                                            <label className="text-[10px] text-slate-500">{t('angle_deg')}</label>
                                            <input type="number" className={inputClass} value={data.angle} onChange={e=>update('angle', e.target.value)} />
                                        </div>
                                    </div>

                                    {/* Ref Toggle */}
                                    <div className="flex gap-2 text-[10px] mb-1">
                                        <label className="text-slate-500 pt-1">{t('ref')}:</label>
                                        <button onClick={()=>update('angleRef', 'global')} className={`px-2 py-0.5 rounded ${data.angleRef==='global'?'bg-blue-600':'bg-slate-700 text-slate-300'}`}>{t('global')}</button>
                                        <button onClick={()=>update('angleRef', 'local')} className={`px-2 py-0.5 rounded ${data.angleRef==='local'?'bg-blue-600':'bg-slate-700 text-slate-300'}`}>{t('local')}</button>
                                    </div>

                                    <div>
                                        <label className="text-[10px] text-slate-500">{t('dist')} (m)</label>
                                        <input type="number" className={inputClass} value={data.dist} onChange={e=>update('dist', e.target.value)} />
                                    </div>
                                </>
                            )}

                            {/* DISTRIBUTED */}
                            {data.type === 'dist' && (
                                <>
                                    <div className="grid grid-cols-2 gap-2 mb-2">
                                        <div>
                                            {/* Reuse 'mag' translation + manual Start/End labels */}
                                            <label className="text-[10px] text-slate-500">{t('mag')} Start (kN/m)</label>
                                            <input type="number" className={inputClass} value={data.wStart} onChange={e=>update('wStart', e.target.value)} />
                                        </div>
                                        <div>
                                            <label className="text-[10px] text-slate-500">{t('mag')} End (kN/m)</label>
                                            <input type="number" className={inputClass} value={data.wEnd} onChange={e=>update('wEnd', e.target.value)} />
                                        </div>
                                    </div>
                                    <div className="mb-2">
                                        <label className="text-[10px] text-slate-500">{t('angle_deg')}</label>
                                        <input type="number" className={inputClass} value={data.angle} onChange={e=>update('angle', e.target.value)} />
                                    </div>
                                    
                                    {/* Ref Toggle */}
                                    <div className="flex gap-2 text-[10px] mb-2">
                                        <label className="text-slate-500 pt-1">{t('ref')}:</label>
                                        <button onClick={()=>update('angleRef', 'global')} className={`px-2 py-0.5 rounded ${data.angleRef==='global'?'bg-blue-600 text-white':'bg-slate-700 text-slate-300'}`}>{t('global')}</button>
                                        <button onClick={()=>update('angleRef', 'local')} className={`px-2 py-0.5 rounded ${data.angleRef==='local'?'bg-blue-600 text-white':'bg-slate-700 text-slate-300'}`}>{t('local')}</button>
                                    </div>
                                    
                                    <div className="grid grid-cols-2 gap-2">
                                        <div>
                                            <label className="text-[10px] text-slate-500">{t('dist_start')} (m)</label>
                                            <input type="number" className={inputClass} value={data.dStart} onChange={e=>update('dStart', e.target.value)} />
                                        </div>
                                        <div>
                                            <label className="text-[10px] text-slate-500">{t('dist_end')} (m)</label>
                                            <input type="number" className={inputClass} value={data.dEnd} onChange={e=>update('dEnd', e.target.value)} />
                                        </div>
                                    </div>
                                </>
                            )}
                            
                            {/* SETTLEMENT */}
                            {data.type === 'settlement' && (
                                <div className="grid grid-cols-2 gap-2">
                                    <div>
                                        <label className="text-[10px] text-slate-500">{t('lbl_dx')}</label>
                                        <input type="number" className={inputClass} value={data.dx} onChange={e=>update('dx', e.target.value)} />
                                    </div>
                                    <div>
                                        <label className="text-[10px] text-slate-500">{t('lbl_dy')}</label>
                                        <input type="number" className={inputClass} value={data.dy} onChange={e=>update('dy', e.target.value)} />
                                    </div>
                                </div>
                            )}
                        </div>

                        <div className="flex gap-2">
                            <button onClick={onCancel} className="flex-1 bg-slate-700 hover:bg-slate-600 text-xs py-2 rounded">Cancel</button>
                            <button onClick={() => onConfirm(data)} className="flex-1 bg-blue-600 hover:bg-blue-500 text-xs py-2 rounded font-bold">Apply Load</button>
                        </div>
                    </div>
                </div>
            );
        };
        // ==========================================
        // TIER 2: CONTROLLER (REACT APP)
        // ==========================================
        // [MODIFY] Robust Icon Component to fix missing icons
            
        // [ADD] Translations Dictionary
        const TRANSLATIONS = {
            en: {
                // ... (Keep English as is)
                sec_lib: "Section Library",
                shape: "Shape",
                saved_sec: "Saved Sections",
                col_name: "Name",
                col_A: "Area (m²)",
                col_I: "Inertia (m⁴)",
                col_E: "E (GPa)",
                sel_sec: "Select Section...",
                save_sec: "Save Section",
                sec_name: "Section Name",
                dims: "Dimensions (mm)",
                depth: "Depth (d)",
                width: "Width (b)",
                web_thk: "Web Thk (tw)",
                flange_thk: "Flange Thk (tf)",
                calc_props: "Calculate Properties",
                shape_rect: "Rectangle",
                shape_i: "I-Shape",
                shape_tri: "Triangle",
                shape_c: "C-Channel",
                shape_circ: "Circle",
                shape_pipe: "Pipe",
                shape_tube: "Tube",
                diameter: "Diameter (d)",
                thickness: "Thickness (t)",
                custom: "Custom",
                res_header_el: "El",
                res_header_m_max: "M_max",
                res_header_m_min: "M_min",
                res_header_v_max: "V_max",
                res_header_v_min: "V_min",
                res_header_n_max: "N_max",
                res_header_n_min: "N_min",
                res_header_d_max: "D_max",
                res_header_d_min: "D_min",
                sett_el: "Element Settings",
                sett_supp: "Support Settings",
                sett_load: "Load Settings",
                title: "WebFEA - 2D Frame Analysis",
                load_portal: "Load Portal Frame Demo",
                load_truss: "Load Truss Bridge Demo",
                save: "Save",
                load: "Load",
                clear: "Clear All",
                nodes: "Nodes",
                elements: "Elements",
                node_list: "Node List",
                member_list: "Member List",
                select_action: "Selection Actions",
                node_sel: "Node Selection",
                beam_sel: "Beam Selection",
                del_node_full: "Delete Node & Support",
                del_supp_only: "Remove Support Only",
                del_sel: "Delete Selection",
                conv_truss: "Convert to Truss Element",
                conv_rigid: "Convert to Normal Frame",
                attached_loads: "Attached Loads",
                clear_loads: "Clear Loads",
                no_supp: "No support attached",
                no_loads: "No loads",
                tool_select: "Select",
                tool_node: "Add Node",
                tool_beam: "Add Beam",
                tool_supp: "Add Support",
                tool_load: "Add Load",
                tool_opt: "Display Options",
                toggle_theme: "Toggle Theme",
                toggle_lang: "Switch Language",
                sett: "Settings",
                el_type: "Element Type",
                normal: "Normal (Rigid)",
                truss: "Truss (Pin)",
                supp_type: "Support Type",
                fixed: "Fixed",
                pin: "Pin",
                roller: "Roller",
                angle: "Angle",
                click_node: "Click node to apply",
                assign_supp: "Assign Support",
                load_type: "Load Type",
                pt_node: "Nodal Point Load",
                pt_beam: "Point on Beam",
                dist_load: "Distributed Load",
                supp_sett: "Support Settlement",
                click_beam_inst: "Click a BEAM on canvas",
                click_node_inst: "Click a NODE on canvas",
                loads_active: "Loads active",
                res_view: "Results View",
                def_shape: "Deformed Shape",
                sfd: "Shear Force (SFD)",
                bmd: "Bending Moment (BMD)",
                afd: "Axial Force (AFD)",
                show_react: "Show Reactions",
                def_scale: "Deformation Scale",
                dia_scale: "Diagram Scale",
                text_size: "Text Size",
                global_ext: "Global Extremes",
                max_m: "Max Moment",
                max_v: "Max Shear",
                max_a: "Max Axial",
                max_d: "Max Disp",
                el_det: "Element",
                moment: "Moment",
                shear: "Shear",
                axial: "Axial",
                defl: "Defl",
                min: "Min",
                max: "Max",
                conf_load: "Configure Load",
                target: "Target",
                beam: "Beam",
                node: "Node",
                mag: "Mag",
                dist_start: "Dist Start",
                dist_end: "Dist End",
                cancel: "Cancel",
                apply: "Apply Load",
                instr_zoom: "Zoom: Scroll | Pan: Drag",
                mode: "Mode",
                click_add: "Click to add",
                click_start: "Click start then end",
                select_items: "Select Nodes/Elements",
                undo: "Undo",
                redo: "Redo",
                geo: "Geo",
                prop: "Prop",
                res: "Res",
                new_prop: "New Beam Properties",
                elastic: "Elastic Modulus (GPa)",
                inertia: "Moment of Inertia (m4)",
                area: "Area (m2)",
                dist: "Distance",
                ref: "Ref",
                global: "Global",
                local: "Local",
                auto_solved: "Auto-Solved",
                el_col: "El",
                m_start: "M_start",
                m_end: "M_end",
                v_start: "V_start",
                tab_geo: "Geometry",
                tab_prop: "Properties",
                tab_loads: "Loads",
                tab_res: "Results",
                select_load_type_lbl: "1. Select Load Type",
                node_label: "Node:",
                angle_deg: "Angle °",
                click_to_apply: "Click nodes on canvas to apply.",
                loads_count: "Loads active",
                lbl_dx: "DX (m)",
                lbl_dy: "DY (m)",
                undo_tip: "Undo (Ctrl+Z)",
                redo_tip: "Redo (Ctrl+Y)",
                toggle_theme_tip: "Toggle Theme",
                toggle_lang_tip: "Switch Language",
                el_info: "Element Information",
                sec_used: "Section",
                length: "Length (m)",
                self_wt: "Self-Weight (kN/m)",
                node_1: "Node 1",
                node_2: "Node 2",
                switch_sec: "Switch Section",
                no_sec: "Custom",
                // Results Tab
                res_no_data: "Add nodes and elements to see results",
                res_elem_forces: "Element Forces Summary",
                res_node_disp: "Node Displacements",
                res_support_react: "Support Reactions",
                res_col_node: "Node",
                res_col_dx: "Δx (mm)",
                res_col_dy: "Δy (mm)",
                res_col_theta: "θ (rad)",
                res_col_rx: "Rx (kN)",
                res_col_ry: "Ry (kN)",
                res_col_rm: "Rm (kNm)",
            },
            zh: {
                sec_lib: "斷面庫",
                shape: "斷面形狀",
                saved_sec: "已存斷面",
                col_name: "名稱",
                col_A: "面積 (m²)",
                col_I: "慣性矩 (m⁴)",
                col_E: "彈性模數 (GPa)",
                sel_sec: "選擇斷面...",
                save_sec: "儲存斷面",
                sec_name: "斷面名稱",
                dims: "尺寸 (mm)",
                depth: "深度 (d)",
                width: "寬度 (b)",
                web_thk: "腹板厚 (tw)",
                flange_thk: "翼板厚 (tf)",
                calc_props: "計算屬性",
                shape_rect: "矩形",
                shape_i: "I型鋼",
                shape_tri: "三角形",
                shape_c: "C型鋼",
                shape_circ: "實心圓",
                shape_pipe: "圓管",
                shape_tube: "方管",
                diameter: "直徑 (d)",
                thickness: "厚度 (t)",
                custom: "自訂",
                res_header_el: "單元",
                res_header_m_max: "M_最大",
                res_header_m_min: "M_最小",
                res_header_v_max: "V_最大",
                res_header_v_min: "V_最小",
                res_header_n_max: "N_最大",
                res_header_n_min: "N_最小",
                res_header_d_max: "D_最大",
                res_header_d_min: "D_最小",
                sett_el: "單元設定",
                sett_supp: "支承設定",
                sett_load: "載重設定",
                title: "WebFEA - 二維框架分析",
                load_portal: "載入剛架範例",
                load_truss: "載入桁架橋範例",
                save: "儲存專案",
                load: "載入專案",
                clear: "清除全部",
                nodes: "節點",
                elements: "單元",
                node_list: "節點列表",
                member_list: "構件列表",
                select_action: "選取操作",
                node_sel: "節點選取",
                beam_sel: "構件選取",
                del_node_full: "刪除節點與支承",
                del_supp_only: "僅移除支承",
                del_sel: "刪除選取項",
                conv_truss: "轉換為桁架單元 (二力桿)",
                conv_rigid: "轉換為剛接構件",
                attached_loads: "附加載重",
                clear_loads: "清除載重",
                no_supp: "無支承",
                no_loads: "無載重",
                tool_select: "選取",
                tool_node: "新增節點",
                tool_beam: "新增梁",
                tool_supp: "新增支承",
                tool_load: "新增載重",
                tool_opt: "顯示選項",
                toggle_theme: "切換主題",
                toggle_lang: "切換語言",
                sett: "設定",
                el_type: "單元類型",
                normal: "一般 (剛接)",
                truss: "桁架 (鉸接)",
                supp_type: "支承類型",
                fixed: "固定端",
                pin: "鉸支承",
                roller: "滾支承",
                angle: "角度",
                click_node: "點擊節點以套用",
                assign_supp: "指定支承",
                load_type: "載重類型",
                pt_node: "節點集中載重",
                pt_beam: "梁上集中載重",
                dist_load: "分佈載重",
                supp_sett: "支承沉陷",
                click_beam_inst: "請點擊畫布上的梁",
                click_node_inst: "請點擊畫布上的節點",
                loads_active: "個載重",
                res_view: "結果視圖",
                def_shape: "變形圖",
                sfd: "剪力圖 (SFD)",
                bmd: "彎矩圖 (BMD)",
                afd: "軸力圖 (AFD)",
                show_react: "顯示反力",
                def_scale: "變形比例",
                dia_scale: "圖表比例",
                text_size: "文字大小",
                global_ext: "全局極值",
                max_m: "最大彎矩",
                max_v: "最大剪力",
                max_a: "最大軸力",
                max_d: "最大位移",
                el_det: "單元",
                moment: "彎矩",
                shear: "剪力",
                axial: "軸力",
                defl: "撓度",
                min: "最小",
                max: "最大",
                conf_load: "設定載重",
                target: "目標",
                beam: "梁",
                node: "節點",
                mag: "大小",
                dist_start: "起始距離",
                dist_end: "結束距離",
                cancel: "取消",
                apply: "套用載重",
                instr_zoom: "縮放: 滾輪 | 平移: 拖曳",
                mode: "模式",
                click_add: "點擊以新增",
                click_start: "點擊起點與終點",
                select_items: "選取節點/單元",
                undo: "復原",
                redo: "重做",
                geo: "幾何",
                prop: "屬性",
                res: "結果",
                new_prop: "新梁屬性",
                elastic: "彈性模數 (GPa)",
                inertia: "慣性矩 (m4)",
                area: "斷面積 (m2)",
                dist: "距離",
                ref: "參考座標",
                global: "全域",
                local: "局部",
                auto_solved: "自動求解完成",
                el_col: "單元",
                m_start: "M_起",
                m_end: "M_終",
                v_start: "V_起",
                tab_geo: "幾何",
                tab_prop: "屬性",
                tab_loads: "載重",
                tab_res: "結果",
                select_load_type_lbl: "1. 選擇載重類型",
                node_label: "節點:",
                angle_deg: "角度 °",
                click_to_apply: "在畫布上點擊節點以套用。",
                loads_count: "個有效載重",
                lbl_dx: "X方向位移 (m)",
                lbl_dy: "Y方向位移 (m)",
                undo_tip: "復原 (Ctrl+Z)",
                redo_tip: "重做 (Ctrl+Y)",
                toggle_theme_tip: "切換主題",
                toggle_lang_tip: "切換語言",
                el_info: "單元資訊",
                sec_used: "斷面",
                length: "長度 (m)",
                self_wt: "自重 (kN/m)",
                node_1: "節點 1",
                node_2: "節點 2",
                switch_sec: "切換斷面",
                no_sec: "自訂",
                // Results Tab
                res_no_data: "新增節點與單元以查看結果",
                res_elem_forces: "單元內力摘要",
                res_node_disp: "節點位移",
                res_support_react: "支承反力",
                res_col_node: "節點",
                res_col_dx: "Δx (mm)",
                res_col_dy: "Δy (mm)",
                res_col_theta: "θ (rad)",
                res_col_rx: "Rx (kN)",
                res_col_ry: "Ry (kN)",
                res_col_rm: "Rm (kNm)",
            }
        };
        const Icon = React.memo(({ name, className }) => {
            const [svgHtml, setSvgHtml] = useState('');
            
            useEffect(() => {
                // Ensure lucide is loaded from the CDN
                const lucide = window.lucide;
                if (!lucide) {
                    console.warn("Lucide icons not loaded yet");
                    return;
                }

                const pascalName = name
                    .split('-')
                    .map(part => part.charAt(0).toUpperCase() + part.slice(1))
                    .join('');
                
                const iconNode = (lucide.icons && lucide.icons[pascalName]) || lucide[pascalName];

                if (iconNode) {
                    // Fix: Use createIcons/createElement API for newer Lucide versions
                    try {
                        const svgElement = lucide.createElement(iconNode);
                        
                        // Apply attributes manually to ensure compatibility across versions
                        svgElement.setAttribute('class', className);
                        svgElement.setAttribute('width', '24');
                        svgElement.setAttribute('height', '24');
                        svgElement.setAttribute('stroke-width', '2');
                        
                        setSvgHtml(svgElement.outerHTML);
                    } catch (e) {
                        console.error(`Failed to render icon: ${name}`, e);
                    }
                }
            }, [name, className]);

            if (!svgHtml) return <span className={`inline-block ${className}`} />;
            return <span dangerouslySetInnerHTML={{ __html: svgHtml }} className={`inline-flex items-center justify-center shrink-0 ${className}`} />;
        });
        const App = () => {
            const [isDarkMode, setIsDarkMode] = useState(true);
            const [lang, setLang] = useState('en');
            const t = (key) => TRANSLATIONS[lang][key] || key;
            // Dynamic Classes for UI Elements
            const uiClasses = {
                // Floating Panels & Toolbar
                panel: isDarkMode 
                    ? "bg-slate-800/95 border border-slate-700 text-slate-200 shadow-xl backdrop-blur-md" 
                    : "bg-white/95 border border-gray-200 text-gray-700 shadow-xl backdrop-blur-md",
                
                // Sidebar specific (Full height, border right)
                sidebar: isDarkMode
                    ? "bg-slate-900/95 border-r border-slate-700 text-slate-200 backdrop-blur-md"
                    : "bg-white/95 border-r border-gray-200 text-gray-800 backdrop-blur-md",

                // Inner containers (like Node List, Tables)
                innerPanel: isDarkMode
                    ? "bg-slate-800 border border-slate-700"
                    : "bg-gray-50 border border-gray-200",

                // Inputs
                input: isDarkMode 
                    ? "bg-slate-900/50 border-slate-600 text-slate-200 placeholder-slate-500 focus:border-blue-500" 
                    : "bg-white border-gray-300 text-gray-900 placeholder-gray-400 focus:border-blue-600 focus:ring-1 focus:ring-blue-600",
                
                buttonActive: "bg-blue-600 text-white shadow-md hover:bg-blue-500",
                
                buttonInactive: isDarkMode 
                    ? "text-slate-400 hover:bg-slate-700 hover:text-slate-100" 
                    : "text-gray-500 hover:bg-gray-200 hover:text-gray-900",
                
                textMuted: isDarkMode ? "text-slate-500" : "text-gray-400",
                textNorm: isDarkMode ? "text-slate-300" : "text-gray-600",
                
                canvasWrap: isDarkMode ? "bg-slate-950 text-slate-200" : "bg-gray-50 text-gray-800"
            };
            const [nodes, setNodes] = useState([]);
            const [elements, setElements] = useState([]);
            const [supports, setSupports] = useState([]);
            const [loads, setLoads] = useState([]);
            // ... (keep other existing states like results, error, sidebarOpen, tool, etc.) ...
            const [results, setResults] = useState(null);
            const [error, setError] = useState(null);
            const [sidebarOpen, setSidebarOpen] = useState(false);
            const [tool, setTool] = useState('pointer'); 
            const [selectedNode, setSelectedNode] = useState(null);
            const [selectedElement, setSelectedElement] = useState(null);
            const [selectedLoad, setSelectedLoad] = useState(null);
            const [viewSettings, setViewSettings] = useState({ showDeformed: false, showSFD: false, showBMD: false, showAFD: false, showReactions: true, defScale: 100, diaScale: 0.5 });
            const [activeTab, setActiveTab] = useState('geo');
            const [textSize, setTextSize] = useState(11);

            // [FIX] Add missing state variables
            const [suppInput, setSuppInput] = useState({ type: 'fixed', angle: 0, nodeId: '' });
            const [loadType, setLoadType] = useState('point');
            const [pendingLoad, setPendingLoad] = useState(null);
            
            const [elemProp, setElemProp] = useState({ E: 200e6, I: 0.0001, A: 0.01, type: 'rigid', selfWeight: 0 });
            // [MODIFY] Section Library & Params
            // Defaults: E is stored in kPa (200 GPa = 200,000,000 kPa)
            const [sectionLibrary, setSectionLibrary] = useState([
                { name: "Concrete Rect", type: 'rect', d: 500, b: 300, E: 30e9, A: 0.15, I: 0.003125 },
                { name: "Steel I-Beam", type: 'i-shape', d: 400, b: 200, tw: 10, tf: 16, E: 200e9, A: 0.0101, I: 0.000277 },
                { name: "Steel Pipe", type: 'hollow-circ', d: 200, t: 8, E: 200e9, A: 0.0048, I: 0.000022 }
            ]);

            const [secParams, setSecParams] = useState({ name: "", type: 'rect', d: 500, b: 300, tw: 10, tf: 16, t: 10 });

            // [FIX] Auto-Calculate Properties (I, A) whenever Dimensions Change
            useEffect(() => {
                let I = 0, A = 0;
                // Convert mm to meters for calculation
                const d = (parseFloat(secParams.d) || 0) / 1000;
                const b = (parseFloat(secParams.b) || 0) / 1000;
                const tw = (parseFloat(secParams.tw) || 0) / 1000;
                const tf = (parseFloat(secParams.tf) || 0) / 1000;
                const t = (parseFloat(secParams.t) || 0) / 1000;

                if (secParams.type === 'rect') {
                    if (b > 0 && d > 0) {
                        A = b * d;
                        I = (b * Math.pow(d, 3)) / 12;
                    }
                } 
                else if (secParams.type === 'tri') {
                    if (b > 0 && d > 0) {
                        A = (b * d) / 2;
                        I = (b * Math.pow(d, 3)) / 36;
                    }
                }
                else if (secParams.type === 'circ') {
                    if (d > 0) {
                        A = (Math.PI * Math.pow(d, 2)) / 4;
                        I = (Math.PI * Math.pow(d, 4)) / 64;
                    }
                }
                else if (secParams.type === 'hollow-circ') {
                    if (d > 0 && t > 0) {
                        const di = d - 2*t;
                        if(di > 0) {
                            A = (Math.PI * (Math.pow(d, 2) - Math.pow(di, 2))) / 4;
                            I = (Math.PI * (Math.pow(d, 4) - Math.pow(di, 4))) / 64;
                        }
                    }
                }
                else if (secParams.type === 'hollow-rect') {
                    if (b > 0 && d > 0 && t > 0) {
                        const bi = b - 2*t;
                        const di = d - 2*t;
                        if(bi > 0 && di > 0) {
                            A = (b*d) - (bi*di);
                            I = ((b * Math.pow(d, 3)) - (bi * Math.pow(di, 3))) / 12;
                        }
                    }
                }
                else if (secParams.type === 'i-shape') {
                    if (b > 0 && d > 0 && tw > 0 && tf > 0) {
                        const innerH = d - 2 * tf;
                        const innerB = b - tw;
                        I = ((b * Math.pow(d, 3)) - (innerB * Math.pow(innerH, 3))) / 12;
                        A = (2 * b * tf) + (innerH * tw);
                    }
                }
                else if (secParams.type === 'c-shape') {
                    if (b > 0 && d > 0 && tw > 0 && tf > 0) {
                        const innerH = d - 2 * tf;
                        const innerB = b - tw;
                        I = ((b * Math.pow(d, 3)) - (innerB * Math.pow(innerH, 3))) / 12; 
                        A = (2 * b * tf) + (innerH * tw);
                    }
                }
                
                // Update properties automatically
                // We do NOT update E here, E is handled separately
                if (A > 0 && I > 0) {
                    setElemProp(prev => ({ 
                        ...prev, 
                        I: parseFloat(I.toPrecision(4)), 
                        A: parseFloat(A.toPrecision(4)) 
                    }));
                }
            }, [secParams]); // Dependencies: runs when secParams changes

            // [MODIFY] Save Section (Includes E)
            const saveSection = () => {
                if (!secParams.name) return alert("Please enter a name");
                const newSec = { ...secParams, E: elemProp.E, A: elemProp.A, I: elemProp.I };
                setSectionLibrary(prev => [...prev, newSec]);
                alert("Section Saved!");
            };

            // [MODIFY] Load Section
            const loadSection = (index) => {
                if (index === "") return;
                const sec = sectionLibrary[index];
                // 1. Update params (Dimension inputs) -> This triggers useEffect -> Updates I & A
                setSecParams({ 
                    name: sec.name, type: sec.type, 
                    d: sec.d || 0, b: sec.b || 0, tw: sec.tw || 0, tf: sec.tf || 0, t: sec.t || 0 
                });
                // 2. Update E explicitly
                setElemProp(prev => ({ ...prev, E: sec.E }));
            };
            
            // [ADD] State for Display Options Toggle
            const [showDisplayMenu, setShowDisplayMenu] = useState(false);

            // [ADD] History State
            const [history, setHistory] = useState({ past: [], future: [] });

            // [ADD] History Functions
            const addToHistory = () => {
                setHistory(curr => ({
                    past: [...curr.past, { nodes, elements, supports, loads }],
                    future: []
                }));
            };

            const undo = () => {
                if (history.past.length === 0) return;
                const previous = history.past[history.past.length - 1];
                const newPast = history.past.slice(0, -1);
                
                setHistory({
                    past: newPast,
                    future: [{ nodes, elements, supports, loads }, ...history.future]
                });

                setNodes(previous.nodes);
                setElements(previous.elements);
                setSupports(previous.supports);
                setLoads(previous.loads);
                setResults(null);
            };

            const redo = () => {
                if (history.future.length === 0) return;
                const next = history.future[0];
                const newFuture = history.future.slice(1);

                setHistory({
                    past: [...history.past, { nodes, elements, supports, loads }],
                    future: newFuture
                });

                setNodes(next.nodes);
                setElements(next.elements);
                setSupports(next.supports);
                setLoads(next.loads);
                setResults(null);
            };

            // [ADD] Keyboard Shortcuts for Undo/Redo
            useEffect(() => {
                const handleKeyDown = (e) => {
                    if ((e.ctrlKey || e.metaKey) && e.key === 'z') {
                        if (e.shiftKey) redo();
                        else undo();
                    }
                    if ((e.ctrlKey || e.metaKey) && (e.key === 'y')) {
                        redo();
                    }
                };
                window.addEventListener('keydown', handleKeyDown);
                return () => window.removeEventListener('keydown', handleKeyDown);
            }, [history, nodes, elements, supports, loads]);

            const handleCanvasInteract = ({ type, worldPos, snappedPos, nodeId, elementId, loadIndex }) => {
                if (type !== 'click') return;

                if (tool === 'node') {
                    const { x, y } = snappedPos;
                    if (!nodes.find(n => Math.abs(n.x - x) < 0.001 && Math.abs(n.y - y) < 0.001)) {
                        addToHistory(); // <--- ADD THIS
                        setNodes(prev => [...prev, { x, y }]);
                    }
                }
                else if (tool === 'element') {
                    if (nodeId !== null) {
                        if (selectedNode === null) setSelectedNode(nodeId);
                        else if (selectedNode !== nodeId) {
                            addToHistory(); // <--- ADD THIS
                            setElements(prev => [...prev, { 
                                id: prev.length + 1, n1: selectedNode, n2: nodeId, 
                                E: elemProp.E, I: elemProp.I, A: elemProp.A,
                                type: elemProp.type,
                                selfWeight: elemProp.selfWeight || 0
                            }]);  
                            setSelectedNode(null);
                        }
                    } else setSelectedNode(null);
                }
                else if (tool === 'support') {
                    if (nodeId !== null) addSupport(nodeId);
                }
                else if (tool === 'load') {
                    // 1. Check if we clicked something valid for the current Load Type
                    if ((loadType === 'dist' || loadType === 'point_span') && elementId !== null) {
                        // [MODIFY] Calculate Element Length for smart defaults
                        const el = elements.find(e => e.id === elementId);
                        let L = 5; // Fallback
                        if (el) {
                            const n1 = nodes[el.n1];
                            const n2 = nodes[el.n2];
                            L = Math.sqrt(Math.pow(n2.x - n1.x, 2) + Math.pow(n2.y - n1.y, 2));
                        }

                        // Open Modal for Element Load
                        setPendingLoad({
                            type: loadType,
                            elementId: elementId,
                            // Defaults: -90 Local = "Down" (Transverse) in Standard convention
                            mag: 10, angle: -90, angleRef: 'local', 
                            dist: parseFloat((L / 2).toFixed(3)), // Default: Middle of beam
                            wStart: 10, wEnd: 10, 
                            dStart: 0, 
                            dEnd: parseFloat(L.toFixed(3)) // Default: Full length of beam
                        });
                    }
                    else if ((loadType === 'point' || loadType === 'settlement') && nodeId !== null) {
                        // Open Modal for Node Load
                        setPendingLoad({
                            type: loadType,
                            nodeId: nodeId,
                            // Defaults
                            fx: 0, fy: -10, m: 0,
                            dx: 0, dy: 0, dm: 0
                        });
                    }
                }
                else {
                    // Pointer Mode
                    setSelectedNode(nodeId);
                    setSelectedElement(elementId);
                    // [ADD] Set selected load. If a load is clicked, prioritize it over element/node selection
                    if (loadIndex !== null) {
                        setSelectedLoad(loadIndex);
                        setSelectedNode(null); 
                        setSelectedElement(null);
                    } else {
                        // If we clicked a node/element, selectedLoad is null (handled by logic below)
                        // But if we clicked NOTHING (empty space), we need to clear everything.
                        setSelectedLoad(null); 
                    }
                    // Auto-fill inputs based on selection
                    if (nodeId !== null) {
                        setSuppInput(p => ({...p, nodeId: nodeId}));
                    }
                }
            };
            // [ADD] Helper to delete selected load directly
            const deleteSelectedLoad = () => {
                if (selectedLoad !== null) {
                    deleteLoad(selectedLoad);
                    setSelectedLoad(null);
                }
            };

            // ADDED: Auto-Run Solver
            useEffect(() => {
                if (nodes.length < 2 || elements.length === 0) {
                    setResults(null);
                    return;
                }
                try {
                    const solver = new FrameSolver(nodes, elements, supports, loads);
                    const res = solver.calculate();
                    setResults(res);
                    setError(null);
                } catch (e) {
                    // Only log/set error if it's not a transient editing state
                    // For now, we set it so users know if unstable
                    setError(e.message);
                    setResults(null);
                }
            }, [nodes, elements, supports, loads]); // Re-run when these change
            // [ADD] Persistence & File Handling Logic
            const fileInputRef = useRef(null);
            const isInitialized = useRef(false);

            // 1. Auto-Load from Local Storage on Mount
            useEffect(() => {
                const saved = localStorage.getItem('webfea_autosave');
                if (saved) {
                    try {
                        const data = JSON.parse(saved);
                        if (data.nodes) setNodes(data.nodes);
                        if (data.elements) setElements(data.elements);
                        if (data.supports) setSupports(data.supports);
                        if (data.loads) setLoads(data.loads);
                        if (data.viewSettings) setViewSettings(data.viewSettings);
                    } catch (e) {
                        console.error("Failed to restore autosave", e);
                    }
                }
                isInitialized.current = true;
            }, []);

            // 2. Auto-Save to Local Storage on Change
            useEffect(() => {
                if (!isInitialized.current) return; // Prevent overwriting save with empty init state
                const projectData = { nodes, elements, supports, loads, viewSettings };
                localStorage.setItem('webfea_autosave', JSON.stringify(projectData));
            }, [nodes, elements, supports, loads, viewSettings]);

            // 3. File Operations
            const saveProject = () => {
                const projectData = { nodes, elements, supports, loads, viewSettings, version: '1.0' };
                const blob = new Blob([JSON.stringify(projectData, null, 2)], { type: 'application/json' });
                const url = URL.createObjectURL(blob);
                const a = document.createElement('a');
                a.href = url;
                a.download = `webfea_project_${new Date().toISOString().slice(0,10)}.json`;
                a.click();
                URL.revokeObjectURL(url);
            };

            const triggerLoad = () => fileInputRef.current.click();

            const handleFileLoad = (e) => {
                const file = e.target.files[0];
                if (!file) return;
                const reader = new FileReader();
                reader.onload = (event) => {
                    try {
                        const data = JSON.parse(event.target.result);
                        // Load data safely
                        setNodes(data.nodes || []);
                        setElements(data.elements || []);
                        setSupports(data.supports || []);
                        setLoads(data.loads || []);
                        if (data.viewSettings) setViewSettings(data.viewSettings);
                        
                        setResults(null); // Clear old results
                        addToHistory(); // Create undo point
                    } catch (err) {
                        alert("Invalid project file format");
                    }
                };
                reader.readAsText(file);
                e.target.value = null; // Reset input
            };
            const loadDemo = () => {
                setNodes([{x:0, y:0}, {x:0, y:4}, {x:5, y:4}, {x:5, y:0}]);
                setElements([
                    {id:1, n1:0, n2:1, E:200e9, I:0.0002, A:0.01, type:'rigid', selfWeight:0},
                    {id:2, n1:1, n2:2, E:200e9, I:0.0002, A:0.01, type:'rigid', selfWeight:0},
                    {id:3, n1:2, n2:3, E:200e9, I:0.0002, A:0.01, type:'rigid', selfWeight:0}
                ]);
                setSupports([{nodeId:0, rx:true, ry:true, rm:true}, {nodeId:3, rx:true, ry:true, rm:true}]);
                
                // Demo Loads:
                // 1. Roof Load: Distributed 15kN/m (Down relative to beam)
                // 2. Wind Load: Point Load 10kN on the left column (Right relative to column)
                setLoads([
                    {type:'dist', elementId: 2, wStart: 15, wEnd: 15, angle: -90, angleRef: 'local', dStart: 0, dEnd: 5},
                    {type:'point_span', elementId: 1, mag: 10, angle: -90, angleRef: 'local', dist: 2} // -90 Local on vertical col = Right
                ]);
                
                setResults(null);
            };
            const loadTrussDemo = () => {
                // Simple 4-bay Warren Truss
                const w = 4, h = 3;
                setNodes([
                    {x:0, y:0}, {x:w, y:0}, {x:2*w, y:0}, {x:3*w, y:0}, {x:4*w, y:0}, // Bottom Chord: 0,1,2,3,4
                    {x:w/2, y:h}, {x:1.5*w, y:h}, {x:2.5*w, y:h}, {x:3.5*w, y:h}      // Top Chord: 5,6,7,8
                ]);
                
                const defaults = { E:200e9, I:0.0001, A:0.005, type:'truss', selfWeight:0 };
                
                setElements([
                    // Bottom Chord
                    {id:1, n1:0, n2:1, ...defaults}, {id:2, n1:1, n2:2, ...defaults}, 
                    {id:3, n1:2, n2:3, ...defaults}, {id:4, n1:3, n2:4, ...defaults},
                    // Top Chord
                    {id:5, n1:5, n2:6, ...defaults}, {id:6, n1:6, n2:7, ...defaults}, 
                    {id:7, n1:7, n2:8, ...defaults},
                    // Diagonals (Zig-Zag)
                    {id:8, n1:0, n2:5, ...defaults}, {id:9, n1:5, n2:1, ...defaults},
                    {id:10, n1:1, n2:6, ...defaults}, {id:11, n1:6, n2:2, ...defaults},
                    {id:12, n1:2, n2:7, ...defaults}, {id:13, n1:7, n2:3, ...defaults},
                    {id:14, n1:3, n2:8, ...defaults}, {id:15, n1:8, n2:4, ...defaults}
                ]);

                setSupports([
                    {nodeId:0, rx:true, ry:true, rm:false, type:'pin'}, 
                    {nodeId:4, rx:false, ry:true, rm:false, type:'roller'}
                ]);

                setLoads([
                    {type:'point', nodeId:2, fx:0, fy:-50, m:0}, // Load at center bottom
                    {type:'point', nodeId:6, fx:20, fy:0, m:0}   // Wind load top
                ]);
                
                setResults(null);
                setTool('pointer');
            };
            const deleteNode = (index) => {
                addToHistory();
                // 1. Remove Node
                const newNodes = nodes.filter((_, i) => i !== index);
                
                // 2. Remove connected elements and re-index remaining nodes
                const newElements = elements
                    .filter(el => el.n1 !== index && el.n2 !== index)
                    .map(el => ({
                        ...el,
                        n1: el.n1 > index ? el.n1 - 1 : el.n1,
                        n2: el.n2 > index ? el.n2 - 1 : el.n2
                    }));
                
                // 3. Remove supports at node and re-index
                const newSupports = supports
                    .filter(s => s.nodeId !== index)
                    .map(s => ({ ...s, nodeId: s.nodeId > index ? s.nodeId - 1 : s.nodeId }));

                // 4. Remove loads at node/element and re-index node refs
                const newLoads = loads
                    .filter(l => l.nodeId !== index) // Remove point loads on this node
                    .filter(l => l.type !== 'dist' || newElements.find(e => e.id === l.elementId)) // Remove dist loads if element deleted
                    .map(l => l.nodeId !== undefined && l.nodeId > index ? { ...l, nodeId: l.nodeId - 1 } : l);

                setNodes(newNodes);
                setElements(newElements);
                setSupports(newSupports);
                setLoads(newLoads);
                setResults(null);
                setSelectedNode(null);
            };

            const deleteElement = (id) => {
                addToHistory();
                setElements(prev => prev.filter(e => e.id !== id));
                setLoads(prev => prev.filter(l => l.elementId !== id)); // Remove attached dist loads
                setResults(null);
                setSelectedElement(null);
            };
            // [ADD] Function to delete a single specific load
            const deleteLoad = (loadIndex) => {
                addToHistory();
                setLoads(prev => prev.filter((_, i) => i !== loadIndex));
                setResults(null); // Re-solve after deleting load
            };

            const deleteSelection = () => {
                if (selectedLoad !== null) {
                    deleteSelectedLoad();
                } else if (selectedElement !== null) {
                    deleteElement(selectedElement);
                } else if (selectedNode !== null) {
                    deleteNode(selectedNode);
                }
            };
            const addSupport = (targetNodeId = null) => {
                addToHistory();
                const nid = targetNodeId !== null ? targetNodeId : parseInt(suppInput.nodeId);
                if(isNaN(nid) || nid >= nodes.length) return;
                
                // ADDED: Store angle
                let newSupp = { nodeId: nid, rx: false, ry: false, rm: false, angle: parseFloat(suppInput.angle) || 0 };
                
                if (suppInput.type === 'fixed') { 
                    newSupp.rx=true; newSupp.ry=true; newSupp.rm=true; 
                }
                if (suppInput.type === 'pin') { 
                    newSupp.rx=true; newSupp.ry=true; 
                }
                if (suppInput.type === 'roller') { 
                    // Physics Snap: If angle is "vertical-ish" (near 90 or 270), restrain X. Else restrain Y.
                    const a = Math.abs(newSupp.angle % 180);
                    if (a > 45 && a < 135) newSupp.rx = true; // Wall roller
                    else newSupp.ry = true; // Floor roller
                }
                setSupports([...supports.filter(s => s.nodeId !== nid), newSupp]);
            };

            // Called by the Modal when user clicks "Apply"
            const confirmLoad = (loadData) => {
                addToHistory();
                setLoads(prev => [...prev, loadData]);
                setPendingLoad(null); // Close modal
            };
            // [ADD] Calculate Element Stats for Table
            const elementStats = useMemo(() => {
                if (!results || !elements.length) return [];

                return elements.map(el => {
                    const res = results.memberForces.find(f => f.id === el.id);
                    if (!res) return { id: el.id, mMax: 0, mMin: 0, vMax: 0, vMin: 0, nMax: 0, nMin: 0, dMax: 0, dMin: 0 };

                    const n1 = nodes[el.n1], n2 = nodes[el.n2];
                    const dx = n2.x - n1.x, dy = n2.y - n1.y;
                    const L = Math.sqrt(dx*dx + dy*dy);
                    
                    let mMax = -Infinity, mMin = Infinity;
                    let vMax = -Infinity, vMin = Infinity;
                    let nMax = -Infinity, nMin = Infinity;
                    let dMax = -Infinity, dMin = Infinity;

                    // Integrator Loop (20 steps per beam)
                    const steps = 20;
                    for (let i = 0; i <= steps; i++) {
                        const x = (i / steps) * L;
                        
                        // 1. Internal Forces from Reactions
                        let Mx = -res.moment1 + res.shearStart * x;
                        let Vx = res.shearStart;
                        let Ax = res.axial;

                        // 2. Add Loads
                        const elLoads = loads.filter(l => (l.type === 'dist' || l.type === 'point_span') && l.elementId === el.id);
                        elLoads.forEach(l => {
                            const rawAng = (parseFloat(l.angle !== undefined ? l.angle : -90) * Math.PI) / 180;
                            const beamAng = Math.atan2(dy, dx);
                            let effectiveAng = rawAng;
                            if (l.angleRef === 'local') effectiveAng = beamAng + rawAng;
                            const relAng = effectiveAng - beamAng;

                            if (l.type === 'point_span') {
                                let dist = parseFloat(l.dist !== undefined ? l.dist : L/2);
                                if (x > dist) {
                                    const mag = parseFloat(l.mag || 0);
                                    const Px = mag * Math.cos(relAng);
                                    const Py = mag * Math.sin(relAng);
                                    Vx += Py; Ax += Px; Mx += Py * (x - dist);
                                }
                            } else if (l.type === 'dist') {
                                const d1 = parseFloat(l.dStart || 0);
                                const d2 = parseFloat(l.dEnd !== undefined ? l.dEnd : L);
                                const start = Math.max(d1, 0), end = Math.min(d2, x);
                                if (end > start) {
                                    const len = end - start;
                                    const wStart = parseFloat(l.wStart || 0);
                                    const wEnd = parseFloat(l.wEnd !== undefined ? l.wEnd : wStart);
                                    const fullLen = d2 - d1;
                                    const w_s = wStart + (wEnd - wStart) * ((start - d1) / fullLen);
                                    const w_e = wStart + (wEnd - wStart) * ((end - d1) / fullLen);
                                    const area = (w_s + w_e) * 0.5 * len;
                                    const cent = (len * (w_s + 2*w_e)) / (3 * (w_s + w_e));
                                    const cDist = (x - start) - cent;
                                    
                                    const Wx = area * Math.cos(relAng);
                                    const Wy = area * Math.sin(relAng);
                                    Vx += Wy; Ax += Wx; Mx += Wy * cDist;
                                }
                            }
                        });

                        // 3. Displacement Approx (Hermite)
                        const t = x / L;
                        const h1 = 1 - 3*t*t + 2*t*t*t;
                        const h2 = x * (1 - 2*t + t*t);
                        const h3 = 3*t*t - 2*t*t*t;
                        const h4 = x * (t*t - t);
                        const disp = res.dispLocal[1]*h1 + res.dispLocal[2]*h2 + res.dispLocal[4]*h3 + res.dispLocal[5]*h4;

                        if (Mx > mMax) mMax = Mx; if (Mx < mMin) mMin = Mx;
                        if (Vx > vMax) vMax = Vx; if (Vx < vMin) vMin = Vx;
                        if (Ax > nMax) nMax = Ax; if (Ax < nMin) nMin = Ax;
                        if (disp > dMax) dMax = disp; if (disp < dMin) dMin = disp;
                    }

                    return { 
                        id: el.id, 
                        mMax, mMin, vMax, vMin, nMax, nMin, 
                        dMax: dMax * 1000, dMin: dMin * 1000 // Convert m to mm for display
                    };
                });
            }, [results, elements, nodes, loads]);
            return (
                <div className="relative h-screen w-screen bg-slate-900 text-slate-100 font-sans overflow-hidden">
                    
                    {/* [ADD] 1. Menu Button (3 Dots) - Top Left */}
                    <div className="absolute top-4 left-4 z-50">
                        <button 
                            onClick={() => setSidebarOpen(!sidebarOpen)} 
                            className={`p-3 rounded-full shadow-xl border transition-all ${
                                isDarkMode 
                                ? "bg-slate-800/90 border-slate-700 text-blue-400 hover:bg-slate-700" 
                                : "bg-white/90 border-gray-200 text-blue-600 hover:bg-gray-50"
                            }`}
                        >
                            <Icon name="more-vertical" className="w-5 h-5" />
                        </button>
                    </div>

                    {/* [ADD] 2. Floating Tools - Top Right (Mobile Friendly) */}
                    <div className="absolute top-4 right-4 z-50 flex items-start gap-3">
                        
                        {/* DYNAMIC DELETE OPTIONS */}
                        <div className="flex flex-col gap-2">
                            {/* CASE A: Node Selected AND has Support -> Show 2 Choices */}
                            {selectedNode !== null && supports.some(s => s.nodeId === selectedNode) ? (
                                <>
                                    <button 
                                        onClick={() => deleteNode(selectedNode)}
                                        className="bg-red-600 hover:bg-red-500 text-white p-3 rounded-xl shadow-xl border border-red-500 transition-all flex items-center group relative"
                                        title={t('del_node_full')} // [MODIFY]
                                    >
                                        <Icon name="trash-2" className="w-5 h-5" />
                                        <span className="absolute right-full mr-2 bg-slate-900 text-white text-[10px] px-2 py-1 rounded opacity-0 group-hover:opacity-100 transition-opacity whitespace-nowrap pointer-events-none">
                                            {t('del_node_full')} {/* [MODIFY] */}
                                        </span>
                                    </button>
                                    
                                    <button 
                                        onClick={() => { addToHistory(); setSupports(s => s.filter(x => x.nodeId !== selectedNode)); }}
                                        className="bg-orange-600 hover:bg-orange-500 text-white p-3 rounded-xl shadow-xl border border-orange-500 transition-all flex items-center group relative"
                                        title={t('del_supp_only')} // [MODIFY]
                                    >
                                        <Icon name="minus-circle" className="w-5 h-5" />
                                        <span className="absolute right-full mr-2 bg-slate-900 text-white text-[10px] px-2 py-1 rounded opacity-0 group-hover:opacity-100 transition-opacity whitespace-nowrap pointer-events-none">
                                            {t('del_supp_only')} {/* [MODIFY] */}
                                        </span>
                                    </button>
                                </>
                            ) : (
                                /* CASE B: Standard Delete (Element, Load, or Node without support) */
                                (selectedNode !== null || selectedElement !== null || selectedLoad !== null) && (
                                    <button 
                                        onClick={deleteSelection}
                                        className="bg-red-600 hover:bg-red-500 text-white p-3 rounded-xl shadow-xl border border-red-500 transition-all"
                                        title={t('del_sel')} // [MODIFY]
                                    >
                                        <Icon name="trash-2" className="w-5 h-5" />
                                    </button>
                                )
                            )}
                        </div>

                        {/* Toolbar */}
                        <div className={`${uiClasses.panel} p-2 rounded-2xl flex flex-col gap-2`}>
                            {/* Theme & Language Toggles */}
                            
                            <div className="flex gap-2">
                                <button onClick={() => setIsDarkMode(!isDarkMode)} className={`p-3 rounded-xl transition-all flex-1 ${uiClasses.buttonInactive}`} title={t('toggle_theme_tip')}>
                                    <Icon name={isDarkMode ? "sun" : "moon"} className="w-5 h-5 mx-auto" />
                                </button>
                                <button onClick={() => setLang(l => l === 'en' ? 'zh' : 'en')} className={`p-3 rounded-xl transition-all flex-1 font-bold text-xs ${uiClasses.buttonInactive}`} title={t('toggle_lang')}>
                                    {lang === 'en' ? '中' : 'EN'}
                                </button>
                            </div>
                            <div className="w-full h-px bg-slate-700/50 my-1"></div>
                            {/* [ADD] Undo / Redo */}
                            <div className="flex flex-col gap-1 border-b border-slate-700 pb-2 mb-1">
                                <button onClick={undo} disabled={history.past.length === 0} className={`p-2 rounded-xl transition-all ${history.past.length === 0 ? 'text-slate-600 cursor-not-allowed' : 'text-slate-400 hover:bg-slate-700 hover:text-white'}`} title={t('undo_tip')}>
                                    <Icon name="undo-2" className="w-5 h-5" />
                                </button>
                                <button onClick={redo} disabled={history.future.length === 0} className={`p-2 rounded-xl transition-all ${history.future.length === 0 ? 'text-slate-600 cursor-not-allowed' : 'text-slate-400 hover:bg-slate-700 hover:text-white'}`} title={t('redo_tip')}>
                                    <Icon name="redo-2" className="w-5 h-5" />
                                </button>
                            </div>

                            <button onClick={() => setTool('pointer')} className={`p-3 rounded-xl transition-all ${tool === 'pointer' ? 'bg-blue-600 text-white shadow-lg' : 'text-slate-400 hover:bg-slate-700'}`} title={t('tool_select')}>
                                <Icon name="mouse-pointer-2" className="w-5 h-5" />
                            </button>
                            <button onClick={() => setTool('node')} className={`p-3 rounded-xl transition-all ${tool === 'node' ? 'bg-blue-600 text-white shadow-lg' : 'text-slate-400 hover:bg-slate-700'}`} title={t('tool_node')}>
                                <Icon name="circle" className="w-5 h-5" />
                            </button>
                            <button onClick={() => setTool('element')} className={`p-3 rounded-xl transition-all ${tool === 'element' ? 'bg-blue-600 text-white shadow-lg' : 'text-slate-400 hover:bg-slate-700'}`} title={t('tool_beam')}>
                                <Icon name="slash" className="w-5 h-5" />
                            </button>
                            <button onClick={() => { setTool('support'); setActiveTab('load'); }} className={`p-3 rounded-xl transition-all ${tool === 'support' ? 'bg-blue-600 text-white shadow-lg' : 'text-slate-400 hover:bg-slate-700'}`} title={t('tool_supp')}>
                                <Icon name="triangle" className="w-5 h-5" />
                            </button>
                            <button onClick={() => { setTool('load'); setActiveTab('load'); }} className={`p-3 rounded-xl transition-all ${tool === 'load' ? 'bg-blue-600 text-white shadow-lg' : 'text-slate-400 hover:bg-slate-700'}`} title={t('tool_load')}>
                                <Icon name="arrow-down" className="w-5 h-5" />
                            </button>
                            {/* [ADD] Display Options Toggle Button */}
                            <div className="w-full h-px bg-slate-700 my-1"></div> {/* Separator */}
                            <button 
                                onClick={() => setShowDisplayMenu(!showDisplayMenu)} 
                                className={`p-3 rounded-xl transition-all ${showDisplayMenu ? 'bg-indigo-600 text-white shadow-lg' : 'text-slate-400 hover:bg-slate-700'}`} 
                                title={t('tool_opt')}
                            >
                                <Icon name="eye" className="w-5 h-5" />
                            </button>
                        </div>
                        
                    </div>
                    {/* 3. Tool Configuration Window (Floating) */}
                    {(tool === 'element' || tool === 'support' || tool === 'load') && (
                        <div className="absolute top-4 right-20 z-50 w-48 animate-in fade-in slide-in-from-right-5 duration-200">
                            <div className={`${uiClasses.panel} backdrop-blur p-3 rounded-xl shadow-2xl flex flex-col gap-3`}>
                                
                                {/* HEADER */}
                                <div className="flex justify-between items-center border-b border-slate-700 pb-2">
                                    <span className="text-xs font-bold uppercase tracking-wider">
                                        {tool === 'element' ? t('sett_el') : tool === 'support' ? t('sett_supp') : t('sett_load')}
                                    </span>
                                    <button onClick={() => setTool('pointer')} className="text-slate-400 hover:text-white"><Icon name="x" className="w-3 h-3" /></button>
                                </div>

                                {/* ELEMENT OPTIONS */}
                                {tool === 'element' && (
                                    <div className="flex flex-col gap-2">
                                        <label className="text-[10px] text-slate-400">{t('el_type')}</label>
                                        <div className="flex bg-slate-900 p-1 rounded-lg">
                                            <button onClick={()=>setElemProp(p=>({...p, type:'rigid'}))} className={`flex-1 text-[10px] py-1.5 rounded-md transition-colors ${elemProp.type==='rigid'?'bg-blue-600 text-white shadow':'text-slate-500 hover:text-slate-300'}`}>{t('normal')}</button>
                                            <button onClick={()=>setElemProp(p=>({...p, type:'truss'}))} className={`flex-1 text-[10px] py-1.5 rounded-md transition-colors ${elemProp.type==='truss'?'bg-blue-600 text-white shadow':'text-slate-500 hover:text-slate-300'}`}>{t('truss')}</button>
                                        </div>
                                        
                                        {/* Convert Selection Button */}
                                        {selectedElement !== null && (
                                            <button onClick={() => { 
                                                addToHistory();
                                                setElements(prev => prev.map(e => e.id === selectedElement ? { ...e, type: e.type === 'truss' ? 'rigid' : 'truss' } : e));
                                            }} className="bg-slate-600 hover:bg-slate-500 text-white text-[10px] py-2 rounded mt-1">
                                                {elements.find(e => e.id === selectedElement)?.type === 'truss' ? t('conv_rigid') : t('conv_truss')}
                                            </button>
                                        )}
                                    </div>
                                )}

                                {/* SUPPORT OPTIONS */}
                                {tool === 'support' && (
                                    <div className="flex flex-col gap-2">
                                        <label className="text-[10px] text-slate-400">{t('supp_type')}</label>
                                        <div className="grid grid-cols-3 gap-1 bg-slate-900 p-1 rounded-lg">
                                            {['fixed', 'pin', 'roller'].map(type => (
                                                <button key={type} onClick={()=>setSuppInput(p=>({...p, type}))} 
                                                    className={`text-[10px] py-1.5 rounded-md capitalize transition-colors ${suppInput.type===type ? 'bg-emerald-600 text-white shadow' : 'text-slate-500 hover:text-slate-300'}`}>
                                                    {t(type)}
                                                </button>
                                            ))}
                                        </div>
                                        <div className="flex items-center gap-2 mt-1">
                                            <label className="text-[10px] text-slate-500 w-12">{t('angle')}</label>
                                            <input type="number" className={`w-full rounded px-2 py-1 text-xs focus:outline-none focus:border-blue-500 border ${uiClasses.input}`} value={suppInput.angle} onChange={e=>setSuppInput({...suppInput, angle:e.target.value})} />
                                        </div>
                                        <div className="text-[10px] text-emerald-400 italic text-center mt-1">{t('click_node')}</div>
                                    </div>
                                )}

                                {/* LOAD OPTIONS */}
                                {tool === 'load' && (
                                    <div className="flex flex-col gap-2">
                                        <label className="text-[10px] text-slate-400">{t('load_type')}</label>
                                        <select className={`w-full rounded px-2 py-1 text-xs focus:outline-none focus:border-blue-500 border ${uiClasses.input}`} value={loadType} onChange={e=>setLoadType(e.target.value)}>
                                            <option value="point">{t('pt_node')}</option>
                                            <option value="point_span">{t('pt_beam')}</option>
                                            <option value="dist">{t('dist_load')}</option>
                                            <option value="settlement">{t('supp_sett')}</option>
                                        </select>
                                        <div className="text-[10px] text-yellow-400 italic text-center mt-1">
                                            {(loadType === 'dist' || loadType === 'point_span') ? t('click_beam_inst') : t('click_node_inst')}
                                        </div>
                                        <div className="mt-1 text-xs text-slate-500 border-t border-slate-700 pt-2 text-center">
                                            {loads.length} {t('loads_count')}
                                        </div>
                                    </div>
                                )}

                            </div>
                        </div>
                    )}
                    {/* 4. Display Options Panel (Floating) */}
                    {showDisplayMenu && (
                        <div className="absolute top-4 right-20 z-50 w-56 animate-in fade-in slide-in-from-right-5 duration-200">
                            <div className={`${uiClasses.panel} backdrop-blur p-3 rounded-xl shadow-2xl flex flex-col gap-2`}>
                                
                                {/* HEADER */}
                                <div className="flex justify-between items-center border-b border-slate-700 pb-2 mb-1">
                                    <span className="text-xs font-bold uppercase tracking-wider flex items-center gap-2">
                                        <Icon name="bar-chart-2" className="w-3 h-3" /> {t('res_view')}
                                    </span>
                                    <button onClick={() => setShowDisplayMenu(false)} className="text-slate-400 hover:text-white"><Icon name="x" className="w-3 h-3" /></button>
                                </div>

                                {/* CHECKBOXES */}
                                <div className="space-y-2">
                                    <label className="flex items-center gap-3 text-[11px] text-slate-300 cursor-pointer hover:text-white transition-colors">
                                        <div className={`w-4 h-4 rounded border flex items-center justify-center transition-colors ${viewSettings.showDeformed ? 'bg-emerald-600 border-emerald-500' : 'border-slate-500 bg-slate-900'}`}>
                                            {viewSettings.showDeformed && <Icon name="check" className="w-3 h-3 text-white" />}
                                        </div>
                                        <input type="checkbox" className="hidden" checked={viewSettings.showDeformed} onChange={e=>setViewSettings({...viewSettings, showDeformed:e.target.checked})} />
                                        {t('def_shape')}
                                    </label>

                                    <label className="flex items-center gap-3 text-[11px] text-slate-300 cursor-pointer hover:text-white transition-colors">
                                        <div className={`w-4 h-4 rounded border flex items-center justify-center transition-colors ${viewSettings.showSFD ? 'bg-blue-600 border-blue-500' : 'border-slate-500 bg-slate-900'}`}>
                                            {viewSettings.showSFD && <Icon name="check" className="w-3 h-3 text-white" />}
                                        </div>
                                        <input type="checkbox" className="hidden" checked={viewSettings.showSFD} onChange={e=>setViewSettings({...viewSettings, showSFD:e.target.checked})} />
                                        {t('sfd')}
                                    </label>

                                    <label className="flex items-center gap-3 text-[11px] text-slate-300 cursor-pointer hover:text-white transition-colors">
                                        <div className={`w-4 h-4 rounded border flex items-center justify-center transition-colors ${viewSettings.showBMD ? 'bg-red-600 border-red-500' : 'border-slate-500 bg-slate-900'}`}>
                                            {viewSettings.showBMD && <Icon name="check" className="w-3 h-3 text-white" />}
                                        </div>
                                        <input type="checkbox" className="hidden" checked={viewSettings.showBMD} onChange={e=>setViewSettings({...viewSettings, showBMD:e.target.checked})} />
                                        {t('bmd')}
                                    </label>

                                    <label className="flex items-center gap-3 text-[11px] text-slate-300 cursor-pointer hover:text-white transition-colors">
                                        <div className={`w-4 h-4 rounded border flex items-center justify-center transition-colors ${viewSettings.showAFD ? 'bg-pink-600 border-pink-500' : 'border-slate-500 bg-slate-900'}`}>
                                            {viewSettings.showAFD && <Icon name="check" className="w-3 h-3 text-white" />}
                                        </div>
                                        <input type="checkbox" className="hidden" checked={viewSettings.showAFD} onChange={e=>setViewSettings({...viewSettings, showAFD:e.target.checked})} />
                                        {t('afd')}
                                    </label>

                                    <div className="h-px bg-slate-700 my-1"></div>

                                    <label className="flex items-center gap-3 text-[11px] text-slate-300 cursor-pointer hover:text-white transition-colors">
                                        <div className={`w-4 h-4 rounded border flex items-center justify-center transition-colors ${viewSettings.showReactions ? 'bg-green-600 border-green-500' : 'border-slate-500 bg-slate-900'}`}>
                                            {viewSettings.showReactions && <Icon name="check" className="w-3 h-3 text-white" />}
                                        </div>
                                        <input type="checkbox" className="hidden" checked={viewSettings.showReactions} onChange={e=>setViewSettings({...viewSettings, showReactions:e.target.checked})} />
                                        {t('show_react')}
                                    </label>
                                </div>

                                {/* SCALES */}
                                <div className="mt-2 pt-2 border-t border-slate-700 space-y-3">
                                    <div>
                                        <div className="flex justify-between text-[10px] text-slate-400 mb-1">
                                            <span>{t('def_scale')}</span>
                                            <span>{viewSettings.defScale}x</span>
                                        </div>
                                        <input type="range" min="1" max="200" value={viewSettings.defScale} onChange={e=>setViewSettings({...viewSettings, defScale:Number(e.target.value)})} className="w-full h-1 bg-slate-600 rounded-lg appearance-none cursor-pointer accent-blue-500"/>
                                    </div>
                                    <div>
                                        <div className="flex justify-between text-[10px] text-slate-400 mb-1">
                                            <span>{t('dia_scale')}</span>
                                            <span>{viewSettings.diaScale}x</span>
                                        </div>
                                        <input type="range" min="0.1" max="5" step="0.1" value={viewSettings.diaScale} onChange={e=>setViewSettings({...viewSettings, diaScale:Number(e.target.value)})} className="w-full h-1 bg-slate-600 rounded-lg appearance-none cursor-pointer accent-blue-500"/>
                                    </div>
                                </div>

                            </div>
                        </div>
                    )}
                    {/* [MODIFY] 3. Sidebar - Collapsible with Slide Transition */}
                    <div className={`absolute top-0 left-0 h-full w-80 flex flex-col z-40 shadow-2xl transition-transform duration-300 ease-in-out ${sidebarOpen ? 'translate-x-0' : '-translate-x-full'} ${uiClasses.sidebar}`}>

                        {/* Header with Close Button */}
                        <div className={`p-4 border-b flex justify-between items-center ${isDarkMode ? 'border-slate-700' : 'border-gray-200'}`}>
                            <h1 className="text-xl font-bold flex items-center gap-2 text-blue-600"><Icon name="activity" className="w-5 h-5" /> WebFEA</h1>
                            <button onClick={() => setSidebarOpen(false)} className={isDarkMode ? "text-slate-400 hover:text-white" : "text-gray-400 hover:text-gray-900"}><Icon name="x" className="w-5 h-5" /></button>
                        </div>

                        <div className="flex-1 overflow-y-auto p-4 space-y-6">
                            {/* Project File Management */}
                            <div className={`grid grid-cols-2 gap-3 pb-4 border-b ${isDarkMode ? 'border-slate-700' : 'border-gray-200'}`}>
                                <button onClick={saveProject} className={`flex items-center justify-center gap-2 py-2 rounded-lg text-xs font-bold border shadow-sm transition-all ${
                                    isDarkMode 
                                    ? "bg-slate-800 border-slate-600 text-blue-400 hover:bg-slate-700" 
                                    : "bg-white border-gray-300 text-blue-600 hover:bg-gray-50"
                                }`}>
                                    <Icon name="save" className="w-4 h-4" /> {t('save')}
                                </button>
                                <button onClick={triggerLoad} className={`flex items-center justify-center gap-2 py-2 rounded-lg text-xs font-bold border shadow-sm transition-all ${
                                    isDarkMode 
                                    ? "bg-slate-800 border-slate-600 text-emerald-400 hover:bg-slate-700" 
                                    : "bg-white border-gray-300 text-emerald-600 hover:bg-gray-50"
                                }`}>
                                    <Icon name="folder-open" className="w-4 h-4" /> {t('load')}
                                </button>
                                <input type="file" ref={fileInputRef} onChange={handleFileLoad} className="hidden" accept=".json" />
                            </div>
                            
                            <button onClick={loadDemo} className={`w-full text-xs py-3 rounded-lg font-medium transition-colors ${isDarkMode ? 'bg-slate-800 hover:bg-slate-700 text-slate-300 border border-slate-600' : 'bg-white hover:bg-gray-50 text-gray-700 border border-gray-200 shadow-sm'}`}>
                                {t('load_portal')}
                            </button>
                            <button onClick={loadTrussDemo} className={`w-full text-xs py-3 rounded-lg font-medium transition-colors ${isDarkMode ? 'bg-slate-800 hover:bg-slate-700 text-slate-300 border border-slate-600' : 'bg-white hover:bg-gray-50 text-gray-700 border border-gray-200 shadow-sm'}`}>
                                {t('load_truss')}
                            </button>
                            {/* ... (Keep existing Selection Actions Panel logic exactly as it was) ... */}
                            {(selectedNode !== null || selectedElement !== null) && (
                                <div className="bg-slate-700 p-2 rounded border border-slate-600 shadow-sm">
                                    <h3 className="text-[10px] font-bold text-white uppercase tracking-widest px-1 mb-2">{t('select_action')}</h3>
                                    <div className="flex flex-col gap-2">
                                        {selectedNode !== null && (
                                        <>
                                            <div className="flex justify-between items-center text-xs text-blue-200 px-1">
                                                <span className="font-bold">{selectedNode !== null ? t('node_sel') : t('beam_sel')}</span>
                                                <button onClick={() => setSelectedNode(null)} className="text-slate-400 hover:text-white"><Icon name="x" className="w-3 h-3" /></button>
                                            </div>

                                            {/* PRIMARY OPTIONS */}
                                            <div className="flex flex-col gap-2 mt-3">
                                                {/* Option 1: Delete Node (Entirely) */}
                                                <button onClick={() => deleteNode(selectedNode)} className="bg-red-600 hover:bg-red-500 text-white text-xs py-2 rounded flex items-center justify-center gap-2 font-bold shadow-sm">
                                                    <Icon name="trash-2" className="w-4 h-4" />
                                                {t('del_node_full')}</button>

                                                {/* Option 2: Delete Support Only */}
                                                {supports.some(s => s.nodeId === selectedNode) ? (
                                                    <button onClick={() => setSupports(s => s.filter(x => x.nodeId !== selectedNode))} className="bg-orange-700 hover:bg-orange-600 text-white text-xs py-2 rounded flex items-center justify-center gap-2 font-bold shadow-sm">
                                                        <Icon name="minus-circle" className="w-4 h-4" />
                                                    {t('del_supp_only')}</button>
                                                ) : (
                                                    <div className="text-[10px] text-slate-500 text-center py-1 border border-slate-700 rounded border-dashed">
                                                        No support attached
                                                    </div>
                                                )}
                                            </div>

                                            {/* Secondary Info: Attached Loads */}
                                            <div className="mt-4 border-t border-slate-600 pt-2">
                                                <div className="flex justify-between items-center mb-1">
                                                    <span className="text-[10px] font-bold text-slate-400 uppercase">Attached Loads</span>
                                                    {loads.some(l => l.nodeId === selectedNode) && (
                                                        <button onClick={() => setLoads(l => l.filter(x => x.nodeId !== selectedNode))} className="text-[10px] text-yellow-500 hover:text-yellow-400 underline">Clear Loads</button>
                                                    )}
                                                </div>
                                                <div className="flex flex-col gap-1 mt-1 max-h-32 overflow-y-auto">
                                                    {loads.map((l, index) => {
                                                        if (l.nodeId !== selectedNode) return null;
                                                        return (
                                                            <div key={index} className="flex justify-between items-center bg-slate-800 p-1.5 rounded text-[10px] border border-slate-600">
                                                                <span className="text-slate-300">
                                                                    {l.type === 'settlement' ? 'Settlement' : `Force: ${l.fx||0}, ${l.fy||0}`}
                                                                </span>
                                                                <button onClick={() => deleteLoad(index)} className="text-red-400 hover:text-red-300 p-1">
                                                                    <Icon name="trash-2" className="w-3 h-3" />
                                                                </button>
                                                            </div>
                                                        );
                                                    })}
                                                    {!loads.some(l => l.nodeId === selectedNode) && (
                                                        <span className="text-[10px] text-slate-500 italic text-center">No loads</span>
                                                    )}
                                                </div>
                                            </div>
                                        </>
                                    )}
                                    
                                    {selectedElement !== null && (
                                        <>
                                            <div className={`flex justify-between items-center text-xs text-blue-200 px-1 ${selectedNode !== null ? 'border-t border-slate-600 pt-2 mt-1' : ''}`}>
                                                <span>Beam {selectedElement}</span>
                                                <button onClick={() => setSelectedElement(null)} className="text-slate-400 hover:text-white"><Icon name="x" className="w-3 h-3" /></button>
                                            </div>
                                            
                                            {/* Element Info Display */}
                                            {(() => {
                                                const el = elements.find(e => e.id === selectedElement);
                                                if (!el) return null;
                                                
                                                const n1 = nodes[el.n1];
                                                const n2 = nodes[el.n2];
                                                const L = Math.sqrt(Math.pow(n2.x - n1.x, 2) + Math.pow(n2.y - n1.y, 2));
                                                
                                                // Find matching section from library
                                                const matchedSec = sectionLibrary.find(sec => 
                                                    Math.abs(sec.E - el.E) < 1e3 && 
                                                    Math.abs(sec.I - el.I) < 1e-8 && 
                                                    Math.abs(sec.A - el.A) < 1e-6
                                                );
                                                
                                                return (
                                                    <div className="mt-2 p-2 bg-slate-900/50 rounded border border-slate-700 text-[10px] space-y-1">
                                                        <div className="font-bold text-blue-300 mb-2 border-b border-slate-700 pb-1">{t('el_info')}</div>
                                                        
                                                        <div className="grid grid-cols-2 gap-x-3 gap-y-1">
                                                            <span className="text-slate-400">{t('sec_used')}:</span>
                                                            <span className="text-slate-200 font-mono">{matchedSec ? matchedSec.name : t('no_sec')}</span>
                                                            
                                                            <span className="text-slate-400">{t('area')}:</span>
                                                            <span className="text-slate-200 font-mono">{el.A.toExponential(2)} m²</span>
                                                            
                                                            <span className="text-slate-400">{t('inertia')}:</span>
                                                            <span className="text-slate-200 font-mono">{el.I.toExponential(2)} m⁴</span>
                                                            
                                                            <span className="text-slate-400">{t('elastic')}:</span>
                                                            <span className="text-slate-200 font-mono">{(el.E / 1e9).toFixed(0)} GPa</span>
                                                            
                                                            <span className="text-slate-400">{t('length')}:</span>
                                                            <span className="text-slate-200 font-mono">{L.toFixed(3)} m</span>
                                                            
                                                            <span className="text-slate-400">{t('self_wt')}:</span>
                                                            <span className="text-slate-200 font-mono">{el.selfWeight || 0} kN/m</span>
                                                            
                                                            <span className="text-slate-400">{t('node_1')}:</span>
                                                            <span className="text-slate-200 font-mono">{el.n1}</span>
                                                            
                                                            <span className="text-slate-400">{t('node_2')}:</span>
                                                            <span className="text-slate-200 font-mono">{el.n2}</span>
                                                        </div>
                                                    </div>
                                                );
                                            })()}
                                            
                                            <div className="grid grid-cols-1 gap-2 mt-2">
                                                {/* Switch Section Dropdown */}
                                                <select 
                                                    className={`w-full rounded px-2 py-1 text-[10px] border ${uiClasses.input}`}
                                                    onChange={(e) => {
                                                        if (e.target.value === "") return;
                                                        addToHistory();
                                                        const sec = sectionLibrary[parseInt(e.target.value)];
                                                        setElements(prev => prev.map(el => 
                                                            el.id === selectedElement 
                                                            ? { ...el, E: sec.E, I: sec.I, A: sec.A }
                                                            : el
                                                        ));
                                                        e.target.value = ""; // Reset dropdown
                                                    }}
                                                    defaultValue=""
                                                >
                                                    <option value="">{t('switch_sec')}</option>
                                                    {sectionLibrary.map((sec, i) => (
                                                        <option key={i} value={i}>{sec.name}</option>
                                                    ))}
                                                </select>
                                                
                                                {/* Toggle Type Button */}
                                                <button onClick={() => { 
                                                    addToHistory();
                                                    setElements(prev => prev.map(e => e.id === selectedElement ? { ...e, type: e.type === 'truss' ? 'rigid' : 'truss' } : e));
                                                }} className="bg-slate-600 hover:bg-slate-500 text-white text-[10px] py-1 rounded">
                                                    {t(elements.find(e => e.id === selectedElement)?.type === 'truss' ? 'conv_rigid' : 'conv_truss')}
                                                </button>
                                            </div>
                                        </>
                                    )}
                                    
                                    </div>
                                </div>
                            )}

                            {/* ... (Keep existing Tabs and Tab Content logic exactly as it was) ... */}
                            <div className="flex gap-2 border-b border-slate-700 pb-2">
                                {/* Removed 'load' from the array */}
                                {['geo', 'prop', 'res'].map(tab => (
                                    <button key={tab} onClick={() => setActiveTab(tab)} className={`text-xs px-2 py-1 rounded font-medium transition-colors ${activeTab===tab ? 'bg-blue-600 text-white' : `${uiClasses.textMuted} hover:bg-gray-100/10`}`}>
                                        {/* Logic simplified since 'load' is gone */}
                                        {tab === 'geo' ? t('tab_geo') : tab === 'prop' ? t('tab_prop') : t('tab_res')}
                                    </button>
                                ))}
                            </div>

                            {activeTab === 'geo' && (
                                <div className={`space-y-4 text-xs ${uiClasses.textMuted}`}>
                                    <p>{t('nodes')}: {nodes.length} | {t('elements')}: {elements.length}</p>
                                    
                                    {/* Node List */}
                                    <div className={`${uiClasses.innerPanel} p-2 rounded max-h-40 overflow-y-auto`}>
                                        <div className={`font-bold mb-1 ${isDarkMode ? 'text-slate-200' : 'text-gray-700'}`}>{t('node_list')}</div>
                                        {nodes.map((n,i) => (
                                            <div key={i} className={`flex justify-between border-b py-1 ${isDarkMode ? 'border-slate-700' : 'border-gray-200 text-gray-600'}`}>
                                                <span>{i}</span><span>{n.x.toFixed(1)}, {n.y.toFixed(1)}</span>
                                            </div>
                                        ))}
                                    </div>

                                    {/* Member List */}
                                    <div className={`${uiClasses.innerPanel} p-2 rounded max-h-40 overflow-y-auto`}>
                                        <div className={`font-bold mb-1 ${isDarkMode ? 'text-slate-200' : 'text-gray-700'}`}>{t('member_list')}</div>
                                        {elements.map((e,i) => (
                                            <div key={i} className={`flex justify-between border-b py-1 ${isDarkMode ? 'border-slate-700' : 'border-gray-200 text-gray-600'}`}>
                                                <span>{e.id}</span><span>{e.n1} → {e.n2}</span>
                                            </div>
                                        ))}
                                    </div>
                                    
                                    <button onClick={()=>{setNodes([]); setElements([]); setSupports([]); setLoads([]); setResults(null);}} className="w-full bg-red-900/50 hover:bg-red-900 text-red-200 py-1 rounded">{t('clear')}</button>
                                </div>
                            )}
                            {activeTab === 'res' && (
                                <div className="space-y-4">
                                    {!results ? (
                                        <div className={`${uiClasses.innerPanel} p-4 rounded text-center`}>
                                            <Icon name="info" className="w-8 h-8 mx-auto mb-2 text-slate-500" />
                                            <p className={`text-xs ${uiClasses.textMuted}`}>
                                                {error || t('res_no_data')}
                                            </p>
                                        </div>
                                    ) : (
                                        <>
                                            {/* Element Forces Summary Table */}
                                            <div className={`${uiClasses.innerPanel} p-0 rounded overflow-hidden`}>
                                                <div className={`p-2 font-bold text-xs border-b ${isDarkMode ? 'bg-slate-800 border-slate-700 text-slate-300' : 'bg-gray-100 border-gray-200 text-gray-700'}`}>
                                                    {t('res_elem_forces')}
                                                </div>
                                                <div className="max-h-64 overflow-y-auto">
                                                    <table className="w-full text-left border-collapse">
                                                        <thead className={`text-[9px] sticky top-0 ${isDarkMode ? 'bg-slate-800' : 'bg-gray-100'} ${uiClasses.textMuted}`}>
                                                            <tr>
                                                                <th className="p-1.5 font-normal">{t('res_header_el')}</th>
                                                                <th className="p-1.5 font-normal text-right">{t('res_header_m_max')}</th>
                                                                <th className="p-1.5 font-normal text-right">{t('res_header_m_min')}</th>
                                                                <th className="p-1.5 font-normal text-right">{t('res_header_v_max')}</th>
                                                                <th className="p-1.5 font-normal text-right">{t('res_header_v_min')}</th>
                                                                <th className="p-1.5 font-normal text-right">{t('res_header_n_max')}</th>
                                                            </tr>
                                                        </thead>
                                                        <tbody className={`text-[9px] font-mono ${isDarkMode ? 'text-slate-400' : 'text-gray-600'}`}>
                                                            {elementStats.map((stat) => (
                                                                <tr key={stat.id} className={`border-b last:border-0 hover:bg-blue-500/10 cursor-pointer ${isDarkMode ? 'border-slate-800' : 'border-gray-100'}`}
                                                                    onClick={() => { setSelectedElement(stat.id); setTool('pointer'); }}>
                                                                    <td className="p-1.5 font-bold text-blue-400">{stat.id}</td>
                                                                    <td className="p-1.5 text-right text-red-400">{stat.mMax.toFixed(2)}</td>
                                                                    <td className="p-1.5 text-right text-red-300">{stat.mMin.toFixed(2)}</td>
                                                                    <td className="p-1.5 text-right text-blue-400">{stat.vMax.toFixed(2)}</td>
                                                                    <td className="p-1.5 text-right text-blue-300">{stat.vMin.toFixed(2)}</td>
                                                                    <td className="p-1.5 text-right text-pink-400">{stat.nMax.toFixed(2)}</td>
                                                                </tr>
                                                            ))}
                                                        </tbody>
                                                    </table>
                                                </div>
                                            </div>

                                            {/* Node Displacements */}
                                            <div className={`${uiClasses.innerPanel} p-0 rounded overflow-hidden`}>
                                                <div className={`p-2 font-bold text-xs border-b ${isDarkMode ? 'bg-slate-800 border-slate-700 text-slate-300' : 'bg-gray-100 border-gray-200 text-gray-700'}`}>
                                                    {t('res_node_disp')}
                                                </div>
                                                <div className="max-h-48 overflow-y-auto">
                                                    <table className="w-full text-left border-collapse">
                                                        <thead className={`text-[9px] sticky top-0 ${isDarkMode ? 'bg-slate-800' : 'bg-gray-100'} ${uiClasses.textMuted}`}>
                                                            <tr>
                                                                <th className="p-1.5 font-normal">{t('res_col_node')}</th>
                                                                <th className="p-1.5 font-normal text-right">{t('res_col_dx')}</th>
                                                                <th className="p-1.5 font-normal text-right">{t('res_col_dy')}</th>
                                                                <th className="p-1.5 font-normal text-right">{t('res_col_theta')}</th>
                                                            </tr>
                                                        </thead>
                                                        <tbody className={`text-[9px] font-mono ${isDarkMode ? 'text-slate-400' : 'text-gray-600'}`}>
                                                            {nodes.map((_, i) => {
                                                                const dx = results.displacements[3*i] * 1000; // Convert to mm
                                                                const dy = results.displacements[3*i+1] * 1000;
                                                                const theta = results.displacements[3*i+2];
                                                                return (
                                                                    <tr key={i} className={`border-b last:border-0 hover:bg-blue-500/10 ${isDarkMode ? 'border-slate-800' : 'border-gray-100'}`}>
                                                                        <td className="p-1.5 font-bold text-blue-400">{i}</td>
                                                                        <td className="p-1.5 text-right">{dx.toFixed(3)}</td>
                                                                        <td className="p-1.5 text-right">{dy.toFixed(3)}</td>
                                                                        <td className="p-1.5 text-right">{theta.toExponential(2)}</td>
                                                                    </tr>
                                                                );
                                                            })}
                                                        </tbody>
                                                    </table>
                                                </div>
                                            </div>

                                            {/* Support Reactions */}
                                            {supports.length > 0 && (
                                                <div className={`${uiClasses.innerPanel} p-0 rounded overflow-hidden`}>
                                                    <div className={`p-2 font-bold text-xs border-b ${isDarkMode ? 'bg-slate-800 border-slate-700 text-slate-300' : 'bg-gray-100 border-gray-200 text-gray-700'}`}>
                                                        {t('res_support_react')}
                                                    </div>
                                                    <div className="max-h-48 overflow-y-auto">
                                                        <table className="w-full text-left border-collapse">
                                                            <thead className={`text-[9px] sticky top-0 ${isDarkMode ? 'bg-slate-800' : 'bg-gray-100'} ${uiClasses.textMuted}`}>
                                                                <tr>
                                                                    <th className="p-1.5 font-normal">{t('res_col_node')}</th>
                                                                    <th className="p-1.5 font-normal text-right">{t('res_col_rx')}</th>
                                                                    <th className="p-1.5 font-normal text-right">{t('res_col_ry')}</th>
                                                                    <th className="p-1.5 font-normal text-right">{t('res_col_rm')}</th>
                                                                </tr>
                                                            </thead>
                                                            <tbody className={`text-[9px] font-mono ${isDarkMode ? 'text-slate-400' : 'text-gray-600'}`}>
                                                                {supports.map((sup) => {
                                                                    const rx = results.reactions[3*sup.nodeId];
                                                                    const ry = results.reactions[3*sup.nodeId+1];
                                                                    const rm = results.reactions[3*sup.nodeId+2];
                                                                    return (
                                                                        <tr key={sup.nodeId} className={`border-b last:border-0 ${isDarkMode ? 'border-slate-800' : 'border-gray-100'}`}>
                                                                            <td className="p-1.5 font-bold text-emerald-400">{sup.nodeId}</td>
                                                                            <td className="p-1.5 text-right text-red-400">{Math.abs(rx).toFixed(2)}</td>
                                                                            <td className="p-1.5 text-right text-red-400">{Math.abs(ry).toFixed(2)}</td>
                                                                            <td className="p-1.5 text-right text-red-400">{Math.abs(rm).toFixed(2)}</td>
                                                                        </tr>
                                                                    );
                                                                })}
                                                            </tbody>
                                                        </table>
                                                    </div>
                                                </div>
                                            )}
                                        </>
                                    )}
                                </div>
                            )}
                            {activeTab === 'prop' && (
                                <div className="space-y-4">
                                    <div className={`${uiClasses.innerPanel} p-3 rounded`}>
                                        <h3 className={`text-xs font-bold mb-3 uppercase ${uiClasses.textMuted}`}>{t('new_prop')}</h3>

                                        <div className={`w-full h-px my-3 ${isDarkMode ? 'bg-slate-700' : 'bg-gray-200'}`}></div>

                                        {/* 2. GEOMETRY INPUTS */}
                                        <div className="mb-3">
                                            {/* [FIX] Shape Selector Button Group + Translation */}
                                            <label className={`text-[10px] font-bold block mb-1.5 ${uiClasses.textMuted}`}>{t('shape')}</label>
                                            <div className="grid grid-cols-4 gap-1 mb-3">
                                                {['rect', 'hollow-rect', 'circ', 'hollow-circ', 'i-shape', 'c-shape', 'tri'].map(type => (
                                                    <button 
                                                        key={type} 
                                                        onClick={() => setSecParams(s => ({...s, type}))}
                                                        className={`text-[9px] py-1 px-0.5 rounded border transition-all truncate ${
                                                            secParams.type === type 
                                                            ? 'bg-blue-600 border-blue-500 text-white shadow-sm' 
                                                            : isDarkMode 
                                                                ? 'bg-slate-800 border-slate-700 text-slate-400 hover:bg-slate-700 hover:text-slate-200' 
                                                                : 'bg-white border-gray-200 text-gray-500 hover:bg-gray-50 hover:text-gray-900'
                                                        }`}
                                                        title={t(type === 'hollow-rect' ? 'shape_tube' : type === 'hollow-circ' ? 'shape_pipe' : `shape_${type.split('-')[0]}`)}
                                                    >
                                                        {t(type === 'hollow-rect' ? 'shape_tube' : type === 'hollow-circ' ? 'shape_pipe' : `shape_${type.split('-')[0]}`)}
                                                    </button>
                                                ))}
                                            </div>

                                            <div className="flex justify-between items-center mb-2">
                                                <label className={`text-[10px] font-bold ${uiClasses.textMuted}`}>{t('dims')}</label>
                                            </div>

                                            <div className="grid grid-cols-2 gap-2 mb-2">
                                                {/* D Input */}
                                                {(secParams.type !== 'circ' && secParams.type !== 'hollow-circ') ? (
                                                    <div>
                                                        <label className={`text-[10px] block ${uiClasses.textMuted}`}>{t('depth')}</label>
                                                        <input type="number" className={`w-full rounded px-2 py-1 text-xs border ${uiClasses.input}`} value={secParams.d} onChange={e => setSecParams({...secParams, d: parseFloat(e.target.value)})} />
                                                    </div>
                                                ) : (
                                                    <div>
                                                        <label className={`text-[10px] block ${uiClasses.textMuted}`}>{t('diameter')}</label>
                                                        <input type="number" className={`w-full rounded px-2 py-1 text-xs border ${uiClasses.input}`} value={secParams.d} onChange={e => setSecParams({...secParams, d: parseFloat(e.target.value)})} />
                                                    </div>
                                                )}

                                                {/* B Input */}
                                                {!(secParams.type === 'circ' || secParams.type === 'hollow-circ') && (
                                                    <div>
                                                        <label className={`text-[10px] block ${uiClasses.textMuted}`}>{t('width')}</label>
                                                        <input type="number" className={`w-full rounded px-2 py-1 text-xs border ${uiClasses.input}`} value={secParams.b} onChange={e => setSecParams({...secParams, b: parseFloat(e.target.value)})} />
                                                    </div>
                                                )}

                                                {/* Thickness (Hollow) */}
                                                {(secParams.type === 'hollow-rect' || secParams.type === 'hollow-circ') && (
                                                    <div>
                                                        <label className={`text-[10px] block ${uiClasses.textMuted}`}>{t('thickness')}</label>
                                                        <input type="number" className={`w-full rounded px-2 py-1 text-xs border ${uiClasses.input}`} value={secParams.t} onChange={e => setSecParams({...secParams, t: parseFloat(e.target.value)})} />
                                                    </div>
                                                )}

                                                {/* I & C Shapes specifics */}
                                                {(secParams.type === 'i-shape' || secParams.type === 'c-shape') && (
                                                    <>
                                                        <div>
                                                            <label className={`text-[10px] block ${uiClasses.textMuted}`}>{t('web_thk')}</label>
                                                            <input type="number" className={`w-full rounded px-2 py-1 text-xs border ${uiClasses.input}`} value={secParams.tw} onChange={e => setSecParams({...secParams, tw: parseFloat(e.target.value)})} />
                                                        </div>
                                                        <div>
                                                            <label className={`text-[10px] block ${uiClasses.textMuted}`}>{t('flange_thk')}</label>
                                                            <input type="number" className={`w-full rounded px-2 py-1 text-xs border ${uiClasses.input}`} value={secParams.tf} onChange={e => setSecParams({...secParams, tf: parseFloat(e.target.value)})} />
                                                        </div>
                                                    </>
                                                )}
                                            </div>
                                        </div>

                                        <div className={`w-full h-px my-3 ${isDarkMode ? 'bg-slate-700' : 'bg-gray-200'}`}></div>

                                        {/* 3. CALCULATED PROPERTIES */}
                                        <div className="space-y-3 mb-3">
                                            {/* Element Type Toggle */}
                                            <div className={`flex p-1 rounded mb-2 ${isDarkMode ? 'bg-slate-900' : 'bg-gray-200'}`}>
                                                <button onClick={()=>setElemProp({...elemProp, type:'rigid'})} className={`flex-1 text-[10px] py-1 rounded ${elemProp.type==='rigid'? uiClasses.buttonActive : (isDarkMode ? 'text-slate-500 hover:text-slate-300' : 'text-gray-500 hover:text-gray-700')}`}>{t('normal')}</button>
                                                <button onClick={()=>setElemProp({...elemProp, type:'truss'})} className={`flex-1 text-[10px] py-1 rounded ${elemProp.type==='truss'? uiClasses.buttonActive : (isDarkMode ? 'text-slate-500 hover:text-slate-300' : 'text-gray-500 hover:text-gray-700')}`}>{t('truss')}</button>
                                            </div>

                                            {/* E Input */}
                                            <div>
                                                <label className={`text-xs block mb-1 ${uiClasses.textMuted}`}>{t('elastic')}</label>
                                                <input type="number" className={`w-full rounded px-2 py-1 text-xs focus:outline-none border ${uiClasses.input}`} value={elemProp.E / 1e6} onChange={e => setElemProp({ ...elemProp, E: parseFloat(e.target.value) * 1e6 })} />
                                            </div>
                                            {/* Self-Weight Input */}
                                            <div>
                                                <label className={`text-xs block mb-1 ${uiClasses.textMuted}`}>{t('self_wt')}</label>
                                                <input type="number" className={`w-full rounded px-2 py-1 text-xs focus:outline-none border ${uiClasses.input}`} value={elemProp.selfWeight} onChange={e => setElemProp({ ...elemProp, selfWeight: parseFloat(e.target.value) || 0 })} />
                                            </div>

                                            {/* Info Grid */}
                                            <div className={`grid grid-cols-2 gap-3 p-3 rounded-lg border ${isDarkMode ? 'bg-slate-900/50 border-slate-700' : 'bg-gray-50 border-gray-200'}`}>
                                                <div className="flex flex-col">
                                                    <span className={`text-[9px] uppercase tracking-wider mb-1 ${uiClasses.textMuted}`}>{t('inertia')}</span>
                                                    <span className={`font-mono text-xs font-bold ${isDarkMode ? 'text-slate-200' : 'text-slate-800'}`}>{Number(elemProp.I).toExponential(3)} m⁴</span>
                                                </div>
                                                <div className="flex flex-col">
                                                    <span className={`text-[9px] uppercase tracking-wider mb-1 ${uiClasses.textMuted}`}>{t('area')}</span>
                                                    <span className={`font-mono text-xs font-bold ${isDarkMode ? 'text-slate-200' : 'text-slate-800'}`}>{Number(elemProp.A).toExponential(3)} m²</span>
                                                </div>
                                            </div>
                                        </div>

                                        {/* 4. SAVE SECTION */}
                                        <div className="flex gap-2 items-end pt-2 border-t border-slate-700/50">
                                            <div className="flex-1">
                                                <label className={`text-[10px] block mb-1 ${uiClasses.textMuted}`}>{t('sec_name')}</label>
                                                <input type="text" className={`w-full rounded px-2 py-1 text-xs border ${uiClasses.input}`} value={secParams.name} onChange={e => setSecParams({...secParams, name: e.target.value})} placeholder="e.g., W200x50" />
                                            </div>
                                            <button onClick={saveSection} className="bg-emerald-600 hover:bg-emerald-500 text-white text-[10px] px-3 py-1.5 rounded font-bold h-8 self-end shadow-md">{t('save_sec')}</button>
                                        </div>
                                    </div>

                                    {/* [ADD] Saved Sections List Table */}
                                    <div className={`${uiClasses.innerPanel} p-0 rounded overflow-hidden`}>
                                        <div className={`p-2 font-bold text-xs border-b ${isDarkMode ? 'bg-slate-800 border-slate-700 text-slate-300' : 'bg-gray-100 border-gray-200 text-gray-700'}`}>
                                            {t('saved_sec')}
                                        </div>
                                        <div className="max-h-40 overflow-y-auto">
                                            <table className="w-full text-left border-collapse">
                                                <thead className={`text-[10px] ${uiClasses.textMuted}`}>
                                                    <tr>
                                                        <th className="p-2 font-normal">{t('col_name')}</th>
                                                        <th className="p-2 font-normal">{t('col_A')}</th>
                                                        <th className="p-2 font-normal">{t('col_I')}</th>
                                                        <th className="p-2 font-normal text-right">{t('col_E')}</th>
                                                    </tr>
                                                </thead>
                                                <tbody className={`text-[10px] font-mono ${isDarkMode ? 'text-slate-400' : 'text-gray-600'}`}>
                                                    {sectionLibrary.map((sec, i) => (
                                                        <tr key={i} className={`border-b last:border-0 ${isDarkMode ? 'border-slate-800' : 'border-gray-100'}`}>
                                                            <td className="p-2 font-sans font-bold text-blue-400 cursor-pointer hover:bg-blue-500/10" onClick={() => loadSection(i)}>{sec.name}</td>
                                                            <td className="p-2 cursor-pointer hover:bg-blue-500/10" onClick={() => loadSection(i)}>{sec.A ? sec.A.toExponential(2) : '-'}</td>
                                                            <td className="p-2 cursor-pointer hover:bg-blue-500/10" onClick={() => loadSection(i)}>{sec.I ? sec.I.toExponential(2) : '-'}</td>
                                                            <td className="p-2 text-right cursor-pointer hover:bg-blue-500/10" onClick={() => loadSection(i)}>{(sec.E / 1e9).toFixed(0)}</td>
                                                            <td className="p-2 text-right">
                                                                <button 
                                                                    onClick={(e) => { 
                                                                        e.stopPropagation(); 
                                                                        setSectionLibrary(prev => prev.filter((_, idx) => idx !== i)); 
                                                                    }} 
                                                                    className="text-red-400 hover:text-red-300 p-1"
                                                                    title="Delete Section"
                                                                >
                                                                    <Icon name="trash-2" className="w-3 h-3" />
                                                                </button>
                                                            </td>
                                                        </tr>
                                                    ))}
                                                </tbody>
                                            </table>
                                        </div>
                                    </div>
                                </div>
                            )}

                        </div>
                        {/* Sidebar Footer (Status) */}
                        <div className={`p-4 border-t ${isDarkMode ? 'border-slate-700 bg-slate-900' : 'border-gray-200 bg-gray-50'}`}>
                             {error ? (
                                <div className="text-red-400 text-xs font-bold flex items-center gap-2"><Icon name="alert-triangle" className="w-4 h-4" /> {error}</div>
                            ) : (
                                <div className="text-emerald-400 text-xs font-bold flex items-center gap-2"><Icon name="check-circle" className="w-4 h-4" /> {t('auto_solved')}</div>
                            )}
                        </div>
                    </div>

                    {/* 4. Canvas Container */}
                    <div className="w-full h-full">
                        {/* [MODIFY] Pass 'selectedLoad' as a prop */}
                        <CanvasView 
                            nodes={nodes} 
                            elements={elements} 
                            supports={supports} 
                            loads={loads} 
                            results={results} 
                            viewSettings={viewSettings} 
                            tool={tool} 
                            selectedNode={selectedNode} 
                            selectedElement={selectedElement} 
                            selectedLoad={selectedLoad} // <--- ADD THIS
                            onCanvasInteract={handleCanvasInteract} 
                            textSize={textSize} 
                            isDarkMode={isDarkMode}
                            t={t}
                        />
                    </div>

                    {/* Modals remain the same */}
                    {pendingLoad && (
                        <LoadModal 
                            loadConfig={pendingLoad} 
                            onConfirm={confirmLoad} 
                            onCancel={() => setPendingLoad(null)} 
                            isDarkMode={isDarkMode} // <--- PASS PROP
                            t={t}
                        />
                    )}
                </div>
            );
        };
        const root = ReactDOM.createRoot(document.getElementById('root'));
        root.render(<App />);
    </script>
</body>
</html>
